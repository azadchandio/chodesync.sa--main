"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next";
exports.ids = ["vendor-chunks/i18next"];
exports.modules = {

/***/ "(ssr)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst isString = (obj)=>typeof obj === \"string\";\nconst defer = ()=>{\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n};\nconst makeString = (object)=>{\n    if (object == null) return \"\";\n    return \"\" + object;\n};\nconst copy = (a, s, t)=>{\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = (key)=>key && key.indexOf(\"###\") > -1 ? key.replace(lastOfPathSeparatorRegExp, \".\") : key;\nconst canNotTraverseDeeper = (object)=>!object || isString(object);\nconst getLastOfPath = (object, path, Empty)=>{\n    const stack = !isString(path) ? path : path.split(\".\");\n    let stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper(object)) return {};\n        const key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper(object)) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n};\nconst setPath = (object, path, newValue)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    let e = path[path.length - 1];\n    let p = path.slice(0, path.length - 1);\n    let last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = `${p[p.length - 1]}.${e}`;\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== \"undefined\") {\n            last.obj = undefined;\n        }\n    }\n    last.obj[`${last.k}.${e}`] = newValue;\n};\nconst pushPath = (object, path, newValue, concat)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n};\nconst getPath = (object, path)=>{\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;\n    return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key)=>{\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite)=>{\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\nconst regexEscape = (str)=>str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nconst escape = (data)=>{\n    if (isString(data)) {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n};\nclass RegExpCache {\n    constructor(capacity){\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n    getRegExp(pattern) {\n        const regExpFromCache = this.regExpMap.get(pattern);\n        if (regExpFromCache !== undefined) {\n            return regExpFromCache;\n        }\n        const regExpNew = new RegExp(pattern);\n        if (this.regExpQueue.length === this.capacity) {\n            this.regExpMap.delete(this.regExpQueue.shift());\n        }\n        this.regExpMap.set(pattern, regExpNew);\n        this.regExpQueue.push(pattern);\n        return regExpNew;\n    }\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator)=>{\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n};\nconst deepFind = function(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) {\n        if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;\n        return obj[path];\n    }\n    const tokens = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < tokens.length;){\n        if (!current || typeof current !== \"object\") {\n            return undefined;\n        }\n        let next;\n        let nextPath = \"\";\n        for(let j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    \"string\",\n                    \"number\",\n                    \"boolean\"\n                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n};\nconst getCleanedCode = (code)=>code?.replace(\"_\", \"-\");\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        console?.[type]?.apply?.(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            if (!this.observers[event]) this.observers[event] = new Map();\n            const numListeners = this.observers[event].get(listener) || 0;\n            this.observers[event].set(listener, numListeners + 1);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event].delete(listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = Array.from(this.observers[event].entries());\n            cloned.forEach((_ref)=>{\n                let [observer, numTimesAdded] = _ref;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer(...args);\n                }\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = Array.from(this.observers[\"*\"].entries());\n            cloned.forEach((_ref2)=>{\n                let [observer, numTimesAdded] = _ref2;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                }\n            });\n        }\n    }\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path;\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        } else {\n            path = [\n                lng,\n                ns\n            ];\n            if (key) {\n                if (Array.isArray(key)) {\n                    path.push(...key);\n                } else if (isString(key) && keySeparator) {\n                    path.push(...key.split(keySeparator));\n                } else {\n                    path.push(key);\n                }\n            }\n        }\n        const result = getPath(this.data, path);\n        if (!result && !ns && !key && lng.indexOf(\".\") > -1) {\n            lng = path[0];\n            ns = path[1];\n            key = path.slice(2).join(\".\");\n        }\n        if (result || !ignoreJSONStructure || !isString(key)) return result;\n        return deepFind(this.data?.[lng]?.[ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false,\n            skipCopy: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            value = this.processors[processor]?.process(value, key, options, translator) ?? value;\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nconst shouldHandleAsObject = (res)=>!isString(res) && typeof res !== \"boolean\" && typeof res !== \"number\";\nclass Translator extends EventEmitter {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key == null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved?.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces: isString(namespaces) ? [\n                        namespaces\n                    ] : namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        return {\n            key,\n            namespaces: isString(namespaces) ? [\n                namespaces\n            ] : namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys == null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng?.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved?.res;\n        const resUsedKey = resolved?.usedKey || key;\n        const resExactUsedKey = resolved?.exactUsedKey || key;\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const needsPluralHandling = options.count !== undefined && !isString(options.count);\n        const hasDefaultValue = Translator.hasDefaultValue(options);\n        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n        const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n            ordinal: false\n        }) : \"\";\n        const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;\n        const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n        let resForObjHndl = res;\n        if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {\n            resForObjHndl = defaultValue;\n        }\n        const handleAsObject = shouldHandleAsObject(resForObjHndl);\n        const resType = Object.prototype.toString.apply(resForObjHndl);\n        if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {\n                    ...options,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = Array.isArray(resForObjHndl);\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in resForObjHndl){\n                    if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        if (hasDefaultValue && !res) {\n                            copy[m] = this.translate(deepKey, {\n                                ...options,\n                                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                        } else {\n                            copy[m] = this.translate(deepKey, {\n                                ...options,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                        }\n                        if (copy[m] === deepKey) copy[m] = resForObjHndl[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector?.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            const suffixes = this.pluralResolver.getSuffixes(language, options);\n                            if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                                suffixes.push(`${this.options.pluralSeparator}zero`);\n                            }\n                            suffixes.forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat?.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = isString(res) && (options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && !isString(options.replace) ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && resolved && resolved.res) options.lng = this.language || resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey?.[0] === args[0] && !options.context) {\n                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = isString(postProcess) ? [\n            postProcess\n        ] : postProcess;\n        if (res != null && postProcessorNames?.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (isString(keys)) keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && !isString(options.count);\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;\n            const needsContextHandling = options.context !== undefined && (isString(options.context) || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat?.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && !isString(options.replace);\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (isString(code) && code.indexOf(\"-\") > -1) {\n            let formattedCode;\n            try {\n                formattedCode = Intl.getCanonicalLocales(code)[0];\n            } catch (e) {}\n            if (formattedCode && this.options.lowerCaseLng) {\n                formattedCode = formattedCode.toLowerCase();\n            }\n            if (formattedCode) return formattedCode;\n            if (this.options.lowerCaseLng) {\n                return code.toLowerCase();\n            }\n            return code;\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(\"-\") > 0 && lngOnly.indexOf(\"-\") < 0 && supportedLng.substring(0, supportedLng.indexOf(\"-\")) === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (isString(fallbacks)) fallbacks = [\n            fallbacks\n        ];\n        if (Array.isArray(fallbacks)) return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (isString(code) && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (isString(code)) {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nconst dummyRule = {\n    select: (count)=>count === 1 ? \"one\" : \"other\",\n    resolvedOptions: ()=>({\n            pluralCategories: [\n                \"one\",\n                \"other\"\n            ]\n        })\n};\nclass PluralResolver {\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        this.pluralRulesCache = {};\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    clearCache() {\n        this.pluralRulesCache = {};\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const cleanedCode = getCleanedCode(code === \"dev\" ? \"en\" : code);\n        const type = options.ordinal ? \"ordinal\" : \"cardinal\";\n        const cacheKey = JSON.stringify({\n            cleanedCode,\n            type\n        });\n        if (cacheKey in this.pluralRulesCache) {\n            return this.pluralRulesCache[cacheKey];\n        }\n        let rule;\n        try {\n            rule = new Intl.PluralRules(cleanedCode, {\n                type\n            });\n        } catch (err) {\n            if (!Intl) {\n                this.logger.error(\"No Intl support, please use an Intl polyfill!\");\n                return dummyRule;\n            }\n            if (!code.match(/-|_/)) return dummyRule;\n            const lngPart = this.languageUtils.getLanguagePartFromCode(code);\n            rule = this.getRule(lngPart, options);\n        }\n        this.pluralRulesCache[cacheKey] = rule;\n        return rule;\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let rule = this.getRule(code, options);\n        if (!rule) rule = this.getRule(\"dev\", options);\n        return rule?.resolvedOptions().pluralCategories.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let rule = this.getRule(code, options);\n        if (!rule) rule = this.getRule(\"dev\", options);\n        if (!rule) return [];\n        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return this.getSuffix(\"dev\", count, options);\n    }\n}\nconst deepFindWithDefaults = function(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && isString(key)) {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n};\nconst regexSafe = (val)=>val.replace(/\\$/g, \"$$$$\");\nclass Interpolator {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options?.interpolation?.format || ((value)=>value);\n        this.init(options);\n    }\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options.interpolation;\n        this.escape = escape$1 !== undefined ? escape$1 : escape;\n        this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || \"{{\";\n        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || \"}}\";\n        this.formatSeparator = formatSeparator || \",\";\n        this.unescapePrefix = unescapeSuffix ? \"\" : unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : unescapeSuffix || \"\";\n        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = nestingOptionsSeparator || \",\";\n        this.maxReplaces = maxReplaces || 1000;\n        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const getOrResetRegExp = (existingRegExp, pattern)=>{\n            if (existingRegExp?.source === pattern) {\n                existingRegExp.lastIndex = 0;\n                return existingRegExp;\n            }\n            return new RegExp(pattern, \"g\");\n        };\n        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = isString(temp) ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (!isString(value) && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        const handleHasOptions = (key, inheritedOptions)=>{\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n            return key;\n        };\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && !isString(value)) return value;\n            if (!isString(value)) value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nconst parseFormatStr = (formatStr)=>{\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (opt) {\n                    const [key, ...rest] = opt.split(\":\");\n                    const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                    const trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === \"false\") formatOptions[trimmedKey] = false;\n                    if (val === \"true\") formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n};\nconst createCachedFormatter = (fn)=>{\n    const cache = {};\n    return (val, lng, options)=>{\n        let optForCache = options;\n        if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {\n            optForCache = {\n                ...optForCache,\n                [options.interpolationkey]: undefined\n            };\n        }\n        const key = lng + JSON.stringify(optForCache);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n};\nclass Formatter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        this.formatSeparator = options.interpolation.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        if (formats.length > 1 && formats[0].indexOf(\"(\") > 1 && formats[0].indexOf(\")\") < 0 && formats.find((f)=>f.indexOf(\")\") > -1)) {\n            const lastIndex = formats.findIndex((f)=>f.indexOf(\")\") > -1);\n            formats[0] = [\n                formats[0],\n                ...formats.splice(1, lastIndex)\n            ].join(this.formatSeparator);\n        }\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options?.formatParams?.[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nconst removePending = (q, name)=>{\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n};\nclass Connector extends EventEmitter {\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        this.backend?.init?.(services, options.backend, options);\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (!err && data) {\n            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                skipCopy: true\n            });\n        }\n        this.state[name] = err ? -1 : 2;\n        if (err && data) this.state[name] = 0;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n        if (isString(namespaces)) namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend?.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nconst get = ()=>({\n        debug: false,\n        initAsync: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: (args)=>{\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (isString(args[1])) ret.defaultValue = args[1];\n            if (isString(args[2])) ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    });\nconst transformOptions = (options)=>{\n    if (isString(options.ns)) options.ns = [\n        options.ns\n    ];\n    if (isString(options.fallbackLng)) options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (isString(options.fallbackNS)) options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs?.indexOf?.(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    if (typeof options.initImmediate === \"boolean\") options.initAsync = options.initImmediate;\n    return options;\n};\nconst noop = ()=>{};\nconst bindMemberFunctions = (inst)=>{\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n};\nclass I18n extends EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initAsync) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        this.isInitializing = true;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (options.defaultNS == null && options.ns) {\n            if (isString(options.ns)) {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        this.options.interpolation = {\n            ...defOpts.interpolation,\n            ...this.options.interpolation\n        };\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        const createClassOnDemand = (ClassOrObject)=>{\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        };\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                this.isInitializing = false;\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initAsync) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = isString(language) ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng?.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            this.options.preload?.forEach?.((l)=>append(l));\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"function\") {\n            callback = lngs;\n            lngs = undefined;\n        }\n        if (typeof ns === \"function\") {\n            callback = ns;\n            ns = undefined;\n        }\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                this.services.languageDetector?.cacheUserLanguage?.(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            if (options.keyPrefix !== \"\") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${options.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (isString(lng)) {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.translator?.translate(...args);\n    }\n    exists() {\n        for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n            args[_key5] = arguments[_key5];\n        }\n        return this.translator?.exists(...args);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 0 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (isString(ns)) ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (isString(lngs)) lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services?.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            const clonedData = Object.keys(this.store.data).reduce((prev, l)=>{\n                prev[l] = {\n                    ...this.store.data[l]\n                };\n                return Object.keys(prev[l]).reduce((acc, n)=>{\n                    acc[n] = {\n                        ...prev[l][n]\n                    };\n                    return acc;\n                }, {});\n            }, {});\n            clone.store = new ResourceStore(clonedData, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++){\n                args[_key6 - 1] = arguments[_key6];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFdBQVdDLENBQUFBLE1BQU8sT0FBT0EsUUFBUTtBQUN2QyxNQUFNQyxRQUFRO0lBQ1osSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU1DLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUNwQ0wsTUFBTUk7UUFDTkgsTUFBTUk7SUFDUjtJQUNBSCxRQUFRRSxPQUFPLEdBQUdKO0lBQ2xCRSxRQUFRRyxNQUFNLEdBQUdKO0lBQ2pCLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNSSxhQUFhQyxDQUFBQTtJQUNqQixJQUFJQSxVQUFVLE1BQU0sT0FBTztJQUMzQixPQUFPLEtBQUtBO0FBQ2Q7QUFDQSxNQUFNQyxPQUFPLENBQUNDLEdBQUdDLEdBQUdDO0lBQ2xCRixFQUFFRyxPQUFPLENBQUNDLENBQUFBO1FBQ1IsSUFBSUgsQ0FBQyxDQUFDRyxFQUFFLEVBQUVGLENBQUMsQ0FBQ0UsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDdkI7QUFDRjtBQUNBLE1BQU1DLDRCQUE0QjtBQUNsQyxNQUFNQyxXQUFXQyxDQUFBQSxNQUFPQSxPQUFPQSxJQUFJQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUlELElBQUlFLE9BQU8sQ0FBQ0osMkJBQTJCLE9BQU9FO0FBQ3ZHLE1BQU1HLHVCQUF1QlosQ0FBQUEsU0FBVSxDQUFDQSxVQUFVVixTQUFTVTtBQUMzRCxNQUFNYSxnQkFBZ0IsQ0FBQ2IsUUFBUWMsTUFBTUM7SUFDbkMsTUFBTUMsUUFBUSxDQUFDMUIsU0FBU3dCLFFBQVFBLE9BQU9BLEtBQUtHLEtBQUssQ0FBQztJQUNsRCxJQUFJQyxhQUFhO0lBQ2pCLE1BQU9BLGFBQWFGLE1BQU1HLE1BQU0sR0FBRyxFQUFHO1FBQ3BDLElBQUlQLHFCQUFxQlosU0FBUyxPQUFPLENBQUM7UUFDMUMsTUFBTVMsTUFBTUQs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QVE7WUFDdkJrUixXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QjJELGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjtRQUN6QztJQUNGO0FBQ0Y7QUFDQSxNQUFNMkMsV0FBVy9ELEtBQUtxRCxjQUFjO0FBQ3BDVSxTQUFTVixjQUFjLEdBQUdyRCxLQUFLcUQsY0FBYztBQUU3QyxNQUFNQSxpQkFBaUJVLFNBQVNWLGNBQWM7QUFDOUMsTUFBTUYsTUFBTVksU0FBU1osR0FBRztBQUN4QixNQUFNaGMsT0FBTzRjLFNBQVM1YyxJQUFJO0FBQzFCLE1BQU04WixnQkFBZ0I4QyxTQUFTOUMsYUFBYTtBQUM1QyxNQUFNSyxrQkFBa0J5QyxTQUFTekMsZUFBZTtBQUNoRCxNQUFNQyxNQUFNd0MsU0FBU3hDLEdBQUc7QUFDeEIsTUFBTWpWLGlCQUFpQnlYLFNBQVN6WCxjQUFjO0FBQzlDLE1BQU00VixZQUFZNkIsU0FBUzdCLFNBQVM7QUFDcEMsTUFBTWpoQixJQUFJOGlCLFNBQVM5aUIsQ0FBQztBQUNwQixNQUFNdUwsU0FBU3VYLFNBQVN2WCxNQUFNO0FBQzlCLE1BQU1pVyxzQkFBc0JzQixTQUFTdEIsbUJBQW1CO0FBQ3hELE1BQU0zUCxxQkFBcUJpUixTQUFTalIsa0JBQWtCO0FBQ3RELE1BQU1pUSxpQkFBaUJnQixTQUFTaEIsY0FBYztBQUM5QyxNQUFNQyxnQkFBZ0JlLFNBQVNmLGFBQWE7QUFFaUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Npc3RpZnktcmVhY3QvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzPzY4ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNTdHJpbmcgPSBvYmogPT4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5jb25zdCBkZWZlciA9ICgpID0+IHtcbiAgbGV0IHJlcztcbiAgbGV0IHJlajtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXMgPSByZXNvbHZlO1xuICAgIHJlaiA9IHJlamVjdDtcbiAgfSk7XG4gIHByb21pc2UucmVzb2x2ZSA9IHJlcztcbiAgcHJvbWlzZS5yZWplY3QgPSByZWo7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IG1ha2VTdHJpbmcgPSBvYmplY3QgPT4ge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuICcnICsgb2JqZWN0O1xufTtcbmNvbnN0IGNvcHkgPSAoYSwgcywgdCkgPT4ge1xuICBhLmZvckVhY2gobSA9PiB7XG4gICAgaWYgKHNbbV0pIHRbbV0gPSBzW21dO1xuICB9KTtcbn07XG5jb25zdCBsYXN0T2ZQYXRoU2VwYXJhdG9yUmVnRXhwID0gLyMjIy9nO1xuY29uc3QgY2xlYW5LZXkgPSBrZXkgPT4ga2V5ICYmIGtleS5pbmRleE9mKCcjIyMnKSA+IC0xID8ga2V5LnJlcGxhY2UobGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCwgJy4nKSA6IGtleTtcbmNvbnN0IGNhbk5vdFRyYXZlcnNlRGVlcGVyID0gb2JqZWN0ID0+ICFvYmplY3QgfHwgaXNTdHJpbmcob2JqZWN0KTtcbmNvbnN0IGdldExhc3RPZlBhdGggPSAob2JqZWN0LCBwYXRoLCBFbXB0eSkgPT4ge1xuICBjb25zdCBzdGFjayA9ICFpc1N0cmluZyhwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBzdGFja0luZGV4ID0gMDtcbiAgd2hpbGUgKHN0YWNrSW5kZXggPCBzdGFjay5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKG9iamVjdCkpIHJldHVybiB7fTtcbiAgICBjb25zdCBrZXkgPSBjbGVhbktleShzdGFja1tzdGFja0luZGV4XSk7XG4gICAgaWYgKCFvYmplY3Rba2V5XSAmJiBFbXB0eSkgb2JqZWN0W2tleV0gPSBuZXcgRW1wdHkoKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHt9O1xuICAgIH1cbiAgICArK3N0YWNrSW5kZXg7XG4gIH1cbiAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKG9iamVjdCkpIHJldHVybiB7fTtcbiAgcmV0dXJuIHtcbiAgICBvYmo6IG9iamVjdCxcbiAgICBrOiBjbGVhbktleShzdGFja1tzdGFja0luZGV4XSlcbiAgfTtcbn07XG5jb25zdCBzZXRQYXRoID0gKG9iamVjdCwgcGF0aCwgbmV3VmFsdWUpID0+IHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkIHx8IHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgb2JqW2tdID0gbmV3VmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICBsZXQgcCA9IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgbGV0IGxhc3QgPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcCwgT2JqZWN0KTtcbiAgd2hpbGUgKGxhc3Qub2JqID09PSB1bmRlZmluZWQgJiYgcC5sZW5ndGgpIHtcbiAgICBlID0gYCR7cFtwLmxlbmd0aCAtIDFdfS4ke2V9YDtcbiAgICBwID0gcC5zbGljZSgwLCBwLmxlbmd0aCAtIDEpO1xuICAgIGxhc3QgPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcCwgT2JqZWN0KTtcbiAgICBpZiAobGFzdD8ub2JqICYmIHR5cGVvZiBsYXN0Lm9ialtgJHtsYXN0Lmt9LiR7ZX1gXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxhc3Qub2JqID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBsYXN0Lm9ialtgJHtsYXN0Lmt9LiR7ZX1gXSA9IG5ld1ZhbHVlO1xufTtcbmNvbnN0IHB1c2hQYXRoID0gKG9iamVjdCwgcGF0aCwgbmV3VmFsdWUsIGNvbmNhdCkgPT4ge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBPYmplY3QpO1xuICBvYmpba10gPSBvYmpba10gfHwgW107XG4gIG9ialtrXS5wdXNoKG5ld1ZhbHVlKTtcbn07XG5jb25zdCBnZXRQYXRoID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoKTtcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBvYmpba107XG59O1xuY29uc3QgZ2V0UGF0aFdpdGhEZWZhdWx0cyA9IChkYXRhLCBkZWZhdWx0RGF0YSwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0UGF0aChkYXRhLCBrZXkpO1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2V0UGF0aChkZWZhdWx0RGF0YSwga2V5KTtcbn07XG5jb25zdCBkZWVwRXh0ZW5kID0gKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpID0+IHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIGlmIChwcm9wICE9PSAnX19wcm90b19fJyAmJiBwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHRhcmdldFtwcm9wXSkgfHwgdGFyZ2V0W3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nIHx8IGlzU3RyaW5nKHNvdXJjZVtwcm9wXSkgfHwgc291cmNlW3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgaWYgKG92ZXJ3cml0ZSkgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0sIG92ZXJ3cml0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCByZWdleEVzY2FwZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbnZhciBfZW50aXR5TWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnLyc6ICcmI3gyRjsnXG59O1xuY29uc3QgZXNjYXBlID0gZGF0YSA9PiB7XG4gIGlmIChpc1N0cmluZyhkYXRhKSkge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIHMgPT4gX2VudGl0eU1hcFtzXSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xuY2xhc3MgUmVnRXhwQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihjYXBhY2l0eSkge1xuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLnJlZ0V4cE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlZ0V4cFF1ZXVlID0gW107XG4gIH1cbiAgZ2V0UmVnRXhwKHBhdHRlcm4pIHtcbiAgICBjb25zdCByZWdFeHBGcm9tQ2FjaGUgPSB0aGlzLnJlZ0V4cE1hcC5nZXQocGF0dGVybik7XG4gICAgaWYgKHJlZ0V4cEZyb21DYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVnRXhwRnJvbUNhY2hlO1xuICAgIH1cbiAgICBjb25zdCByZWdFeHBOZXcgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgIGlmICh0aGlzLnJlZ0V4cFF1ZXVlLmxlbmd0aCA9PT0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgdGhpcy5yZWdFeHBNYXAuZGVsZXRlKHRoaXMucmVnRXhwUXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICAgIHRoaXMucmVnRXhwTWFwLnNldChwYXR0ZXJuLCByZWdFeHBOZXcpO1xuICAgIHRoaXMucmVnRXhwUXVldWUucHVzaChwYXR0ZXJuKTtcbiAgICByZXR1cm4gcmVnRXhwTmV3O1xuICB9XG59XG5jb25zdCBjaGFycyA9IFsnICcsICcsJywgJz8nLCAnIScsICc7J107XG5jb25zdCBsb29rc0xpa2VPYmplY3RQYXRoUmVnRXhwQ2FjaGUgPSBuZXcgUmVnRXhwQ2FjaGUoMjApO1xuY29uc3QgbG9va3NMaWtlT2JqZWN0UGF0aCA9IChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpID0+IHtcbiAgbnNTZXBhcmF0b3IgPSBuc1NlcGFyYXRvciB8fCAnJztcbiAga2V5U2VwYXJhdG9yID0ga2V5U2VwYXJhdG9yIHx8ICcnO1xuICBjb25zdCBwb3NzaWJsZUNoYXJzID0gY2hhcnMuZmlsdGVyKGMgPT4gbnNTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDAgJiYga2V5U2VwYXJhdG9yLmluZGV4T2YoYykgPCAwKTtcbiAgaWYgKHBvc3NpYmxlQ2hhcnMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgciA9IGxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZS5nZXRSZWdFeHAoYCgke3Bvc3NpYmxlQ2hhcnMubWFwKGMgPT4gYyA9PT0gJz8nID8gJ1xcXFw/JyA6IGMpLmpvaW4oJ3wnKX0pYCk7XG4gIGxldCBtYXRjaGVkID0gIXIudGVzdChrZXkpO1xuICBpZiAoIW1hdGNoZWQpIHtcbiAgICBjb25zdCBraSA9IGtleS5pbmRleE9mKGtleVNlcGFyYXRvcik7XG4gICAgaWYgKGtpID4gMCAmJiAhci50ZXN0KGtleS5zdWJzdHJpbmcoMCwga2kpKSkge1xuICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVkO1xufTtcbmNvbnN0IGRlZXBGaW5kID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICBsZXQga2V5U2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLic7XG4gIGlmICghb2JqKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAob2JqW3BhdGhdKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwYXRoKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gb2JqW3BhdGhdO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IHBhdGguc3BsaXQoa2V5U2VwYXJhdG9yKTtcbiAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDspIHtcbiAgICBpZiAoIWN1cnJlbnQgfHwgdHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgbmV4dFBhdGggPSAnJztcbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRva2Vucy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGogIT09IGkpIHtcbiAgICAgICAgbmV4dFBhdGggKz0ga2V5U2VwYXJhdG9yO1xuICAgICAgfVxuICAgICAgbmV4dFBhdGggKz0gdG9rZW5zW2pdO1xuICAgICAgbmV4dCA9IGN1cnJlbnRbbmV4dFBhdGhdO1xuICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXS5pbmRleE9mKHR5cGVvZiBuZXh0KSA+IC0xICYmIGogPCB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gaiAtIGkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuY29uc3QgZ2V0Q2xlYW5lZENvZGUgPSBjb2RlID0+IGNvZGU/LnJlcGxhY2UoJ18nLCAnLScpO1xuXG5jb25zdCBjb25zb2xlTG9nZ2VyID0ge1xuICB0eXBlOiAnbG9nZ2VyJyxcbiAgbG9nKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnbG9nJywgYXJncyk7XG4gIH0sXG4gIHdhcm4oYXJncykge1xuICAgIHRoaXMub3V0cHV0KCd3YXJuJywgYXJncyk7XG4gIH0sXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnZXJyb3InLCBhcmdzKTtcbiAgfSxcbiAgb3V0cHV0KHR5cGUsIGFyZ3MpIHtcbiAgICBjb25zb2xlPy5bdHlwZV0/LmFwcGx5Py4oY29uc29sZSwgYXJncyk7XG4gIH1cbn07XG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3Rvcihjb25jcmV0ZUxvZ2dlcikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmluaXQoY29uY3JldGVMb2dnZXIsIG9wdGlvbnMpO1xuICB9XG4gIGluaXQoY29uY3JldGVMb2dnZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCAnaTE4bmV4dDonO1xuICAgIHRoaXMubG9nZ2VyID0gY29uY3JldGVMb2dnZXIgfHwgY29uc29sZUxvZ2dlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICB9XG4gIGxvZygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ2xvZycsICcnLCB0cnVlKTtcbiAgfVxuICB3YXJuKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJycsIHRydWUpO1xuICB9XG4gIGVycm9yKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdlcnJvcicsICcnKTtcbiAgfVxuICBkZXByZWNhdGUoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ3dhcm4nLCAnV0FSTklORyBERVBSRUNBVEVEOiAnLCB0cnVlKTtcbiAgfVxuICBmb3J3YXJkKGFyZ3MsIGx2bCwgcHJlZml4LCBkZWJ1Z09ubHkpIHtcbiAgICBpZiAoZGVidWdPbmx5ICYmICF0aGlzLmRlYnVnKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNTdHJpbmcoYXJnc1swXSkpIGFyZ3NbMF0gPSBgJHtwcmVmaXh9JHt0aGlzLnByZWZpeH0gJHthcmdzWzBdfWA7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyW2x2bF0oYXJncyk7XG4gIH1cbiAgY3JlYXRlKG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwge1xuICAgICAgLi4ue1xuICAgICAgICBwcmVmaXg6IGAke3RoaXMucHJlZml4fToke21vZHVsZU5hbWV9OmBcbiAgICAgIH0sXG4gICAgICAuLi50aGlzLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjbG9uZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zO1xuICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgdGhpcy5wcmVmaXg7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIodGhpcy5sb2dnZXIsIG9wdGlvbnMpO1xuICB9XG59XG52YXIgYmFzZUxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSB7fTtcbiAgfVxuICBvbihldmVudHMsIGxpc3RlbmVyKSB7XG4gICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkgdGhpcy5vYnNlcnZlcnNbZXZlbnRdID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgbnVtTGlzdGVuZXJzID0gdGhpcy5vYnNlcnZlcnNbZXZlbnRdLmdldChsaXN0ZW5lcikgfHwgMDtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5zZXQobGlzdGVuZXIsIG51bUxpc3RlbmVycyArIDEpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkgcmV0dXJuO1xuICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tldmVudF07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5kZWxldGUobGlzdGVuZXIpO1xuICB9XG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gQXJyYXkuZnJvbSh0aGlzLm9ic2VydmVyc1tldmVudF0uZW50cmllcygpKTtcbiAgICAgIGNsb25lZC5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW29ic2VydmVyLCBudW1UaW1lc0FkZGVkXSA9IF9yZWY7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXNBZGRlZDsgaSsrKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYnNlcnZlcnNbJyonXSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gQXJyYXkuZnJvbSh0aGlzLm9ic2VydmVyc1snKiddLmVudHJpZXMoKSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaChfcmVmMiA9PiB7XG4gICAgICAgIGxldCBbb2JzZXJ2ZXIsIG51bVRpbWVzQWRkZWRdID0gX3JlZjI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXNBZGRlZDsgaSsrKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuYXBwbHkob2JzZXJ2ZXIsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVzb3VyY2VTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgICAgIGRlZmF1bHROUzogJ3RyYW5zbGF0aW9uJ1xuICAgIH07XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYWRkTmFtZXNwYWNlcyhucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihucykgPCAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMucHVzaChucyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU5hbWVzcGFjZXMobnMpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5vcHRpb25zLm5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIGdldFJlc291cmNlKGxuZywgbnMsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGNvbnN0IGlnbm9yZUpTT05TdHJ1Y3R1cmUgPSBvcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSA6IHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlO1xuICAgIGxldCBwYXRoO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgIHBhdGgucHVzaCguLi5rZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGtleSkgJiYga2V5U2VwYXJhdG9yKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKC4uLmtleS5zcGxpdChrZXlTZXBhcmF0b3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCk7XG4gICAgaWYgKCFyZXN1bHQgJiYgIW5zICYmICFrZXkgJiYgbG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBsbmcgPSBwYXRoWzBdO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgICAga2V5ID0gcGF0aC5zbGljZSgyKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgfHwgIWlnbm9yZUpTT05TdHJ1Y3R1cmUgfHwgIWlzU3RyaW5nKGtleSkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIGRlZXBGaW5kKHRoaXMuZGF0YT8uW2xuZ10/Lltuc10sIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICBhZGRSZXNvdXJjZShsbmcsIG5zLCBrZXksIHZhbHVlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSkgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgICB2YWx1ZSA9IG5zO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgIH1cbiAgICB0aGlzLmFkZE5hbWVzcGFjZXMobnMpO1xuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCB2YWx1ZSk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIGtleSwgdmFsdWUpO1xuICB9XG4gIGFkZFJlc291cmNlcyhsbmcsIG5zLCByZXNvdXJjZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge1xuICAgICAgc2lsZW50OiBmYWxzZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtIGluIHJlc291cmNlcykge1xuICAgICAgaWYgKGlzU3RyaW5nKHJlc291cmNlc1ttXSkgfHwgQXJyYXkuaXNBcnJheShyZXNvdXJjZXNbbV0pKSB0aGlzLmFkZFJlc291cmNlKGxuZywgbnMsIG0sIHJlc291cmNlc1ttXSwge1xuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICBhZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCByZXNvdXJjZXMsIGRlZXAsIG92ZXJ3cml0ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgc2tpcENvcHk6IGZhbHNlXG4gICAgfTtcbiAgICBsZXQgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgICBkZWVwID0gcmVzb3VyY2VzO1xuICAgICAgcmVzb3VyY2VzID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuICAgIHRoaXMuYWRkTmFtZXNwYWNlcyhucyk7XG4gICAgbGV0IHBhY2sgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCkgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnNraXBDb3B5KSByZXNvdXJjZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc291cmNlcykpO1xuICAgIGlmIChkZWVwKSB7XG4gICAgICBkZWVwRXh0ZW5kKHBhY2ssIHJlc291cmNlcywgb3ZlcndyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjayA9IHtcbiAgICAgICAgLi4ucGFjayxcbiAgICAgICAgLi4ucmVzb3VyY2VzXG4gICAgICB9O1xuICAgIH1cbiAgICBzZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgcGFjayk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIHJlc291cmNlcyk7XG4gIH1cbiAgcmVtb3ZlUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIGlmICh0aGlzLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSB7XG4gICAgICBkZWxldGUgdGhpcy5kYXRhW2xuZ11bbnNdO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZU5hbWVzcGFjZXMobnMpO1xuICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIGxuZywgbnMpO1xuICB9XG4gIGhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZXNvdXJjZShsbmcsIG5zKSAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5kZWZhdWx0TlM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucyk7XG4gIH1cbiAgZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtsbmddO1xuICB9XG4gIGhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmcpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhQnlMYW5ndWFnZShsbmcpO1xuICAgIGNvbnN0IG4gPSBkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpIHx8IFtdO1xuICAgIHJldHVybiAhIW4uZmluZCh2ID0+IGRhdGFbdl0gJiYgT2JqZWN0LmtleXMoZGF0YVt2XSkubGVuZ3RoID4gMCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxudmFyIHBvc3RQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NvcnM6IHt9LFxuICBhZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSkge1xuICAgIHRoaXMucHJvY2Vzc29yc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG4gIH0sXG4gIGhhbmRsZShwcm9jZXNzb3JzLCB2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKSB7XG4gICAgcHJvY2Vzc29ycy5mb3JFYWNoKHByb2Nlc3NvciA9PiB7XG4gICAgICB2YWx1ZSA9IHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdPy5wcm9jZXNzKHZhbHVlLCBrZXksIG9wdGlvbnMsIHRyYW5zbGF0b3IpID8/IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuY29uc3QgY2hlY2tlZExvYWRlZEZvciA9IHt9O1xuY29uc3Qgc2hvdWxkSGFuZGxlQXNPYmplY3QgPSByZXMgPT4gIWlzU3RyaW5nKHJlcykgJiYgdHlwZW9mIHJlcyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZXMgIT09ICdudW1iZXInO1xuY2xhc3MgVHJhbnNsYXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgY29weShbJ3Jlc291cmNlU3RvcmUnLCAnbGFuZ3VhZ2VVdGlscycsICdwbHVyYWxSZXNvbHZlcicsICdpbnRlcnBvbGF0b3InLCAnYmFja2VuZENvbm5lY3RvcicsICdpMThuRm9ybWF0JywgJ3V0aWxzJ10sIHNlcnZpY2VzLCB0aGlzKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPSAnLic7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ3RyYW5zbGF0b3InKTtcbiAgfVxuICBjaGFuZ2VMYW5ndWFnZShsbmcpIHtcbiAgICBpZiAobG5nKSB0aGlzLmxhbmd1YWdlID0gbG5nO1xuICB9XG4gIGV4aXN0cyhrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgaW50ZXJwb2xhdGlvbjoge31cbiAgICB9O1xuICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXNvbHZlZD8ucmVzICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZXh0cmFjdEZyb21LZXkoa2V5LCBvcHRpb25zKSB7XG4gICAgbGV0IG5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc1NlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICBpZiAobnNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgbnNTZXBhcmF0b3IgPSAnOic7XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBsZXQgbmFtZXNwYWNlcyA9IG9wdGlvbnMubnMgfHwgdGhpcy5vcHRpb25zLmRlZmF1bHROUyB8fCBbXTtcbiAgICBjb25zdCB3b3VsZENoZWNrRm9yTnNJbktleSA9IG5zU2VwYXJhdG9yICYmIGtleS5pbmRleE9mKG5zU2VwYXJhdG9yKSA+IC0xO1xuICAgIGNvbnN0IHNlZW1zTmF0dXJhbExhbmd1YWdlID0gIXRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciAmJiAhb3B0aW9ucy5rZXlTZXBhcmF0b3IgJiYgIXRoaXMub3B0aW9ucy51c2VyRGVmaW5lZE5zU2VwYXJhdG9yICYmICFvcHRpb25zLm5zU2VwYXJhdG9yICYmICFsb29rc0xpa2VPYmplY3RQYXRoKGtleSwgbnNTZXBhcmF0b3IsIGtleVNlcGFyYXRvcik7XG4gICAgaWYgKHdvdWxkQ2hlY2tGb3JOc0luS2V5ICYmICFzZWVtc05hdHVyYWxMYW5ndWFnZSkge1xuICAgICAgY29uc3QgbSA9IGtleS5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgIGlmIChtICYmIG0ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBuYW1lc3BhY2VzOiBpc1N0cmluZyhuYW1lc3BhY2VzKSA/IFtuYW1lc3BhY2VzXSA6IG5hbWVzcGFjZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KG5zU2VwYXJhdG9yKTtcbiAgICAgIGlmIChuc1NlcGFyYXRvciAhPT0ga2V5U2VwYXJhdG9yIHx8IG5zU2VwYXJhdG9yID09PSBrZXlTZXBhcmF0b3IgJiYgdGhpcy5vcHRpb25zLm5zLmluZGV4T2YocGFydHNbMF0pID4gLTEpIG5hbWVzcGFjZXMgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAga2V5ID0gcGFydHMuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlczogaXNTdHJpbmcobmFtZXNwYWNlcykgPyBbbmFtZXNwYWNlc10gOiBuYW1lc3BhY2VzXG4gICAgfTtcbiAgfVxuICB0cmFuc2xhdGUoa2V5cywgb3B0aW9ucywgbGFzdEtleSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgJiYgdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoa2V5cyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSBrZXlzID0gW1N0cmluZyhrZXlzKV07XG4gICAgY29uc3QgcmV0dXJuRGV0YWlscyA9IG9wdGlvbnMucmV0dXJuRGV0YWlscyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZXR1cm5EZXRhaWxzIDogdGhpcy5vcHRpb25zLnJldHVybkRldGFpbHM7XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzXG4gICAgfSA9IHRoaXMuZXh0cmFjdEZyb21LZXkoa2V5c1trZXlzLmxlbmd0aCAtIDFdLCBvcHRpb25zKTtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25hbWVzcGFjZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbG5nID0gb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZTtcbiAgICBjb25zdCBhcHBlbmROYW1lc3BhY2VUb0NJTW9kZSA9IG9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUgfHwgdGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlO1xuICAgIGlmIChsbmc/LnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnKSB7XG4gICAgICBpZiAoYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUpIHtcbiAgICAgICAgY29uc3QgbnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yIHx8IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzOiBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gLFxuICAgICAgICAgICAgdXNlZEtleToga2V5LFxuICAgICAgICAgICAgZXhhY3RVc2VkS2V5OiBrZXksXG4gICAgICAgICAgICB1c2VkTG5nOiBsbmcsXG4gICAgICAgICAgICB1c2VkTlM6IG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHVzZWRQYXJhbXM6IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gO1xuICAgICAgfVxuICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXM6IGtleSxcbiAgICAgICAgICB1c2VkS2V5OiBrZXksXG4gICAgICAgICAgZXhhY3RVc2VkS2V5OiBrZXksXG4gICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgIHVzZWROUzogbmFtZXNwYWNlLFxuICAgICAgICAgIHVzZWRQYXJhbXM6IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKGtleXMsIG9wdGlvbnMpO1xuICAgIGxldCByZXMgPSByZXNvbHZlZD8ucmVzO1xuICAgIGNvbnN0IHJlc1VzZWRLZXkgPSByZXNvbHZlZD8udXNlZEtleSB8fCBrZXk7XG4gICAgY29uc3QgcmVzRXhhY3RVc2VkS2V5ID0gcmVzb2x2ZWQ/LmV4YWN0VXNlZEtleSB8fCBrZXk7XG4gICAgY29uc3Qgbm9PYmplY3QgPSBbJ1tvYmplY3QgTnVtYmVyXScsICdbb2JqZWN0IEZ1bmN0aW9uXScsICdbb2JqZWN0IFJlZ0V4cF0nXTtcbiAgICBjb25zdCBqb2luQXJyYXlzID0gb3B0aW9ucy5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmpvaW5BcnJheXMgOiB0aGlzLm9wdGlvbnMuam9pbkFycmF5cztcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCA9ICF0aGlzLmkxOG5Gb3JtYXQgfHwgdGhpcy5pMThuRm9ybWF0LmhhbmRsZUFzT2JqZWN0O1xuICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQgJiYgIWlzU3RyaW5nKG9wdGlvbnMuY291bnQpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHRWYWx1ZSA9IFRyYW5zbGF0b3IuaGFzRGVmYXVsdFZhbHVlKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVN1ZmZpeCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0aW9ucy5vcmRpbmFsICYmIG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIHtcbiAgICAgIG9yZGluYWw6IGZhbHNlXG4gICAgfSkgOiAnJztcbiAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMDtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBuZWVkc1plcm9TdWZmaXhMb29rdXAgJiYgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gXSB8fCBvcHRpb25zW2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeH1gXSB8fCBvcHRpb25zW2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeE9yZGluYWxGYWxsYmFja31gXSB8fCBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICBsZXQgcmVzRm9yT2JqSG5kbCA9IHJlcztcbiAgICBpZiAoaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgJiYgIXJlcyAmJiBoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJlc0Zvck9iakhuZGwgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0ID0gc2hvdWxkSGFuZGxlQXNPYmplY3QocmVzRm9yT2JqSG5kbCk7XG4gICAgY29uc3QgcmVzVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkocmVzRm9yT2JqSG5kbCk7XG4gICAgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmIHJlc0Zvck9iakhuZGwgJiYgaGFuZGxlQXNPYmplY3QgJiYgbm9PYmplY3QuaW5kZXhPZihyZXNUeXBlKSA8IDAgJiYgIShpc1N0cmluZyhqb2luQXJyYXlzKSAmJiBBcnJheS5pc0FycmF5KHJlc0Zvck9iakhuZGwpKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnJldHVybk9iamVjdHMgJiYgIXRoaXMub3B0aW9ucy5yZXR1cm5PYmplY3RzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2FjY2Vzc2luZyBhbiBvYmplY3QgLSBidXQgcmV0dXJuT2JqZWN0cyBvcHRpb25zIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcihyZXNVc2VkS2V5LCByZXNGb3JPYmpIbmRsLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICB9KSA6IGBrZXkgJyR7a2V5fSAoJHt0aGlzLmxhbmd1YWdlfSknIHJldHVybmVkIGFuIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZy5gO1xuICAgICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmVkLnJlcyA9IHI7XG4gICAgICAgICAgcmVzb2x2ZWQudXNlZFBhcmFtcyA9IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgaWYgKGtleVNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCByZXNUeXBlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkocmVzRm9yT2JqSG5kbCk7XG4gICAgICAgIGNvbnN0IGNvcHkgPSByZXNUeXBlSXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGNvbnN0IG5ld0tleVRvVXNlID0gcmVzVHlwZUlzQXJyYXkgPyByZXNFeGFjdFVzZWRLZXkgOiByZXNVc2VkS2V5O1xuICAgICAgICBmb3IgKGNvbnN0IG0gaW4gcmVzRm9yT2JqSG5kbCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzRm9yT2JqSG5kbCwgbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBLZXkgPSBgJHtuZXdLZXlUb1VzZX0ke2tleVNlcGFyYXRvcn0ke219YDtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0VmFsdWUgJiYgIXJlcykge1xuICAgICAgICAgICAgICBjb3B5W21dID0gdGhpcy50cmFuc2xhdGUoZGVlcEtleSwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzaG91bGRIYW5kbGVBc09iamVjdChkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlW21dIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvcHlbbV0gPT09IGRlZXBLZXkpIGNvcHlbbV0gPSByZXNGb3JPYmpIbmRsW21dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMgPSBjb3B5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgJiYgaXNTdHJpbmcoam9pbkFycmF5cykgJiYgQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICByZXMgPSByZXMuam9pbihqb2luQXJyYXlzKTtcbiAgICAgIGlmIChyZXMpIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXlzLCBvcHRpb25zLCBsYXN0S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVzZWREZWZhdWx0ID0gZmFsc2U7XG4gICAgICBsZXQgdXNlZEtleSA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSAmJiBoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdXNlZERlZmF1bHQgPSB0cnVlO1xuICAgICAgICByZXMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChyZXMpKSB7XG4gICAgICAgIHVzZWRLZXkgPSB0cnVlO1xuICAgICAgICByZXMgPSBrZXk7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgPSBvcHRpb25zLm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBrZXlTZXBhcmF0b3I6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGZrICYmIGZrLnJlcykgdGhpcy5sb2dnZXIud2FybignU2VlbXMgdGhlIGxvYWRlZCB0cmFuc2xhdGlvbnMgd2VyZSBpbiBmbGF0IEpTT04gZm9ybWF0IGluc3RlYWQgb2YgbmVzdGVkLiBFaXRoZXIgc2V0IGtleVNlcGFyYXRvcjogZmFsc2Ugb24gaW5pdCBvciBtYWtlIHN1cmUgeW91ciB0cmFuc2xhdGlvbnMgYXJlIHB1Ymxpc2hlZCBpbiBuZXN0ZWQgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsbmdzID0gW107XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrTG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZywgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2ZhbGxiYWNrJyAmJiBmYWxsYmFja0xuZ3MgJiYgZmFsbGJhY2tMbmdzWzBdKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWxsYmFja0xuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxuZ3MucHVzaChmYWxsYmFja0xuZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IChsLCBrLCBzcGVjaWZpY0RlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRGb3JNaXNzaW5nID0gaGFzRGVmYXVsdFZhbHVlICYmIHNwZWNpZmljRGVmYXVsdFZhbHVlICE9PSByZXMgPyBzcGVjaWZpY0RlZmF1bHRWYWx1ZSA6IHJlc0Zvck1pc3Npbmc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kQ29ubmVjdG9yPy5zYXZlTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4ZXMobGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwICYmIG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gJiYgc3VmZml4ZXMuaW5kZXhPZihgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzdWZmaXhlcy5wdXNoKGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN1ZmZpeGVzLmZvckVhY2goc3VmZml4ID0+IHtcbiAgICAgICAgICAgICAgICBzZW5kKFtsYW5ndWFnZV0sIGtleSArIHN1ZmZpeCwgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHtzdWZmaXh9YF0gfHwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZChsbmdzLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0aW9ucywgcmVzb2x2ZWQsIGxhc3RLZXkpO1xuICAgICAgaWYgKHVzZWRLZXkgJiYgcmVzID09PSBrZXkgJiYgdGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSkgcmVzID0gYCR7bmFtZXNwYWNlfToke2tleX1gO1xuICAgICAgaWYgKCh1c2VkS2V5IHx8IHVzZWREZWZhdWx0KSAmJiB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICByZXMgPSB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcih0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5ID8gYCR7bmFtZXNwYWNlfToke2tleX1gIDoga2V5LCB1c2VkRGVmYXVsdCA/IHJlcyA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICByZXNvbHZlZC5yZXMgPSByZXM7XG4gICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBleHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleSwgb3B0aW9ucywgcmVzb2x2ZWQsIGxhc3RLZXkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQ/LnBhcnNlKSB7XG4gICAgICByZXMgPSB0aGlzLmkxOG5Gb3JtYXQucGFyc2UocmVzLCB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0sIG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZywgcmVzb2x2ZWQudXNlZE5TLCByZXNvbHZlZC51c2VkS2V5LCB7XG4gICAgICAgIHJlc29sdmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNraXBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5pbml0KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ue1xuICAgICAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IGlzU3RyaW5nKHJlcykgJiYgKG9wdGlvbnM/LmludGVycG9sYXRpb24/LnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyA6IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyk7XG4gICAgICBsZXQgbmVzdEJlZjtcbiAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgY29uc3QgbmIgPSByZXMubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICAgIG5lc3RCZWYgPSBuYiAmJiBuYi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBsZXQgZGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcob3B0aW9ucy5yZXBsYWNlKSA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcykgZGF0YSA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICAgIHJlcyA9IHRoaXMuaW50ZXJwb2xhdG9yLmludGVycG9sYXRlKHJlcywgZGF0YSwgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCBvcHRpb25zKTtcbiAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgY29uc3QgbmEgPSByZXMubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICAgIGNvbnN0IG5lc3RBZnQgPSBuYSAmJiBuYS5sZW5ndGg7XG4gICAgICAgIGlmIChuZXN0QmVmIDwgbmVzdEFmdCkgb3B0aW9ucy5uZXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMubG5nICYmIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcykgb3B0aW9ucy5sbmcgPSB0aGlzLmxhbmd1YWdlIHx8IHJlc29sdmVkLnVzZWRMbmc7XG4gICAgICBpZiAob3B0aW9ucy5uZXN0ICE9PSBmYWxzZSkgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IubmVzdChyZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEtleT8uWzBdID09PSBhcmdzWzBdICYmICFvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihgSXQgc2VlbXMgeW91IGFyZSBuZXN0aW5nIHJlY3Vyc2l2ZWx5IGtleTogJHthcmdzWzBdfSBpbiBrZXk6ICR7a2V5WzBdfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IucmVzZXQoKTtcbiAgICB9XG4gICAgY29uc3QgcG9zdFByb2Nlc3MgPSBvcHRpb25zLnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSBpc1N0cmluZyhwb3N0UHJvY2VzcykgPyBbcG9zdFByb2Nlc3NdIDogcG9zdFByb2Nlc3M7XG4gICAgaWYgKHJlcyAhPSBudWxsICYmIHBvc3RQcm9jZXNzb3JOYW1lcz8ubGVuZ3RoICYmIG9wdGlvbnMuYXBwbHlQb3N0UHJvY2Vzc29yICE9PSBmYWxzZSkge1xuICAgICAgcmVzID0gcG9zdFByb2Nlc3Nvci5oYW5kbGUocG9zdFByb2Nlc3Nvck5hbWVzLCByZXMsIGtleSwgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZCA/IHtcbiAgICAgICAgaTE4blJlc29sdmVkOiB7XG4gICAgICAgICAgLi4ucmVzb2x2ZWQsXG4gICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICB9LFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9IDogb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmVzb2x2ZShrZXlzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBmb3VuZDtcbiAgICBsZXQgdXNlZEtleTtcbiAgICBsZXQgZXhhY3RVc2VkS2V5O1xuICAgIGxldCB1c2VkTG5nO1xuICAgIGxldCB1c2VkTlM7XG4gICAgaWYgKGlzU3RyaW5nKGtleXMpKSBrZXlzID0gW2tleXNdO1xuICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGssIG9wdGlvbnMpO1xuICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdGVkLmtleTtcbiAgICAgIHVzZWRLZXkgPSBrZXk7XG4gICAgICBsZXQgbmFtZXNwYWNlcyA9IGV4dHJhY3RlZC5uYW1lc3BhY2VzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja05TKSBuYW1lc3BhY2VzID0gbmFtZXNwYWNlcy5jb25jYXQodGhpcy5vcHRpb25zLmZhbGxiYWNrTlMpO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiAhaXNTdHJpbmcob3B0aW9ucy5jb3VudCk7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMDtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0aW9ucy5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgKGlzU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgfHwgdHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ251bWJlcicpICYmIG9wdGlvbnMuY29udGV4dCAhPT0gJyc7XG4gICAgICBjb25zdCBjb2RlcyA9IG9wdGlvbnMubG5ncyA/IG9wdGlvbnMubG5ncyA6IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSwgb3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkgcmV0dXJuO1xuICAgICAgICB1c2VkTlMgPSBucztcbiAgICAgICAgaWYgKCFjaGVja2VkTG9hZGVkRm9yW2Ake2NvZGVzWzBdfS0ke25zfWBdICYmIHRoaXMudXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy51dGlscz8uaGFzTG9hZGVkTmFtZXNwYWNlKHVzZWROUykpIHtcbiAgICAgICAgICBjaGVja2VkTG9hZGVkRm9yW2Ake2NvZGVzWzBdfS0ke25zfWBdID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBrZXkgXCIke3VzZWRLZXl9XCIgZm9yIGxhbmd1YWdlcyBcIiR7Y29kZXMuam9pbignLCAnKX1cIiB3b24ndCBnZXQgcmVzb2x2ZWQgYXMgbmFtZXNwYWNlIFwiJHt1c2VkTlN9XCIgd2FzIG5vdCB5ZXQgbG9hZGVkYCwgJ1RoaXMgbWVhbnMgc29tZXRoaW5nIElTIFdST05HIGluIHlvdXIgc2V0dXAuIFlvdSBhY2Nlc3MgdGhlIHQgZnVuY3Rpb24gYmVmb3JlIGkxOG5leHQuaW5pdCAvIGkxOG5leHQubG9hZE5hbWVzcGFjZSAvIGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2Ugd2FzIGRvbmUuIFdhaXQgZm9yIHRoZSBjYWxsYmFjayBvciBQcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGFjY2Vzc2luZyBpdCEhIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgICB1c2VkTG5nID0gY29kZTtcbiAgICAgICAgICBjb25zdCBmaW5hbEtleXMgPSBba2V5XTtcbiAgICAgICAgICBpZiAodGhpcy5pMThuRm9ybWF0Py5hZGRMb29rdXBLZXlzKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5Gb3JtYXQuYWRkTG9va3VwS2V5cyhmaW5hbEtleXMsIGtleSwgY29kZSwgbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGNvZGUsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgemVyb1N1ZmZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2A7XG4gICAgICAgICAgICBjb25zdCBvcmRpbmFsUHJlZml4ID0gYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1vcmRpbmFsJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfWA7XG4gICAgICAgICAgICBpZiAobmVlZHNQbHVyYWxIYW5kbGluZykge1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtrZXl9JHt0aGlzLm9wdGlvbnMuY29udGV4dFNlcGFyYXRvcn0ke29wdGlvbnMuY29udGV4dH1gO1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5KTtcbiAgICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgemVyb1N1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwb3NzaWJsZUtleTtcbiAgICAgICAgICB3aGlsZSAocG9zc2libGVLZXkgPSBmaW5hbEtleXMucG9wKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkge1xuICAgICAgICAgICAgICBleGFjdFVzZWRLZXkgPSBwb3NzaWJsZUtleTtcbiAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmdldFJlc291cmNlKGNvZGUsIG5zLCBwb3NzaWJsZUtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXM6IGZvdW5kLFxuICAgICAgdXNlZEtleSxcbiAgICAgIGV4YWN0VXNlZEtleSxcbiAgICAgIHVzZWRMbmcsXG4gICAgICB1c2VkTlNcbiAgICB9O1xuICB9XG4gIGlzVmFsaWRMb29rdXAocmVzKSB7XG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5OdWxsICYmIHJlcyA9PT0gbnVsbCkgJiYgISghdGhpcy5vcHRpb25zLnJldHVybkVtcHR5U3RyaW5nICYmIHJlcyA9PT0gJycpO1xuICB9XG4gIGdldFJlc291cmNlKGNvZGUsIG5zLCBrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgaWYgKHRoaXMuaTE4bkZvcm1hdD8uZ2V0UmVzb3VyY2UpIHJldHVybiB0aGlzLmkxOG5Gb3JtYXQuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VTdG9yZS5nZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zKTtcbiAgfVxuICBnZXRVc2VkUGFyYW1zRGV0YWlscygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qgb3B0aW9uc0tleXMgPSBbJ2RlZmF1bHRWYWx1ZScsICdvcmRpbmFsJywgJ2NvbnRleHQnLCAncmVwbGFjZScsICdsbmcnLCAnbG5ncycsICdmYWxsYmFja0xuZycsICducycsICdrZXlTZXBhcmF0b3InLCAnbnNTZXBhcmF0b3InLCAncmV0dXJuT2JqZWN0cycsICdyZXR1cm5EZXRhaWxzJywgJ2pvaW5BcnJheXMnLCAncG9zdFByb2Nlc3MnLCAnaW50ZXJwb2xhdGlvbiddO1xuICAgIGNvbnN0IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcob3B0aW9ucy5yZXBsYWNlKTtcbiAgICBsZXQgZGF0YSA9IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgaWYgKHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcykge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzdGF0aWMgaGFzRGVmYXVsdFZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnZGVmYXVsdFZhbHVlJztcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikgJiYgcHJlZml4ID09PSBvcHRpb24uc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpICYmIHVuZGVmaW5lZCAhPT0gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY2xhc3MgTGFuZ3VhZ2VVdGlsIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdXBwb3J0ZWRMbmdzID0gdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnbGFuZ3VhZ2VVdGlscycpO1xuICB9XG4gIGdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSB7XG4gICAgY29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUpO1xuICAgIGlmICghY29kZSB8fCBjb2RlLmluZGV4T2YoJy0nKSA8IDApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHAgPSBjb2RlLnNwbGl0KCctJyk7XG4gICAgaWYgKHAubGVuZ3RoID09PSAyKSByZXR1cm4gbnVsbDtcbiAgICBwLnBvcCgpO1xuICAgIGlmIChwW3AubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocC5qb2luKCctJykpO1xuICB9XG4gIGdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIGNvZGU7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocFswXSk7XG4gIH1cbiAgZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpIHtcbiAgICBpZiAoaXNTdHJpbmcoY29kZSkgJiYgY29kZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgbGV0IGZvcm1hdHRlZENvZGU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3JtYXR0ZWRDb2RlID0gSW50bC5nZXRDYW5vbmljYWxMb2NhbGVzKGNvZGUpWzBdO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIGlmIChmb3JtYXR0ZWRDb2RlICYmIHRoaXMub3B0aW9ucy5sb3dlckNhc2VMbmcpIHtcbiAgICAgICAgZm9ybWF0dGVkQ29kZSA9IGZvcm1hdHRlZENvZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXR0ZWRDb2RlKSByZXR1cm4gZm9ybWF0dGVkQ29kZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHJldHVybiBjb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGVhbkNvZGUgfHwgdGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZyA/IGNvZGUudG9Mb3dlckNhc2UoKSA6IGNvZGU7XG4gIH1cbiAgaXNTdXBwb3J0ZWRDb2RlKGNvZGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgPT09ICdsYW5ndWFnZU9ubHknIHx8IHRoaXMub3B0aW9ucy5ub25FeHBsaWNpdFN1cHBvcnRlZExuZ3MpIHtcbiAgICAgIGNvZGUgPSB0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuc3VwcG9ydGVkTG5ncyB8fCAhdGhpcy5zdXBwb3J0ZWRMbmdzLmxlbmd0aCB8fCB0aGlzLnN1cHBvcnRlZExuZ3MuaW5kZXhPZihjb2RlKSA+IC0xO1xuICB9XG4gIGdldEJlc3RNYXRjaEZyb21Db2Rlcyhjb2Rlcykge1xuICAgIGlmICghY29kZXMpIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZDtcbiAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICBjb25zdCBjbGVhbmVkTG5nID0gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzIHx8IHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGNsZWFuZWRMbmcpKSBmb3VuZCA9IGNsZWFuZWRMbmc7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZCAmJiB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ09ubHkgPSB0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpO1xuICAgICAgICBpZiAodGhpcy5pc1N1cHBvcnRlZENvZGUobG5nT25seSkpIHJldHVybiBmb3VuZCA9IGxuZ09ubHk7XG4gICAgICAgIGZvdW5kID0gdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MuZmluZChzdXBwb3J0ZWRMbmcgPT4ge1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcgPT09IGxuZ09ubHkpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPCAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZignLScpID4gMCAmJiBsbmdPbmx5LmluZGV4T2YoJy0nKSA8IDAgJiYgc3VwcG9ydGVkTG5nLnN1YnN0cmluZygwLCBzdXBwb3J0ZWRMbmcuaW5kZXhPZignLScpKSA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YobG5nT25seSkgPT09IDAgJiYgbG5nT25seS5sZW5ndGggPiAxKSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IHRoaXMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpWzBdO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBnZXRGYWxsYmFja0NvZGVzKGZhbGxiYWNrcywgY29kZSkge1xuICAgIGlmICghZmFsbGJhY2tzKSByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBmYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIGZhbGxiYWNrcyA9IGZhbGxiYWNrcyhjb2RlKTtcbiAgICBpZiAoaXNTdHJpbmcoZmFsbGJhY2tzKSkgZmFsbGJhY2tzID0gW2ZhbGxiYWNrc107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkgcmV0dXJuIGZhbGxiYWNrcztcbiAgICBpZiAoIWNvZGUpIHJldHVybiBmYWxsYmFja3MuZGVmYXVsdCB8fCBbXTtcbiAgICBsZXQgZm91bmQgPSBmYWxsYmFja3NbY29kZV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5nZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrcy5kZWZhdWx0O1xuICAgIHJldHVybiBmb3VuZCB8fCBbXTtcbiAgfVxuICB0b1Jlc29sdmVIaWVyYXJjaHkoY29kZSwgZmFsbGJhY2tDb2RlKSB7XG4gICAgY29uc3QgZmFsbGJhY2tDb2RlcyA9IHRoaXMuZ2V0RmFsbGJhY2tDb2RlcyhmYWxsYmFja0NvZGUgfHwgdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIHx8IFtdLCBjb2RlKTtcbiAgICBjb25zdCBjb2RlcyA9IFtdO1xuICAgIGNvbnN0IGFkZENvZGUgPSBjID0+IHtcbiAgICAgIGlmICghYykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGMpKSB7XG4gICAgICAgIGNvZGVzLnB1c2goYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGByZWplY3RpbmcgbGFuZ3VhZ2UgY29kZSBub3QgZm91bmQgaW4gc3VwcG9ydGVkTG5nczogJHtjfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzU3RyaW5nKGNvZGUpICYmIChjb2RlLmluZGV4T2YoJy0nKSA+IC0xIHx8IGNvZGUuaW5kZXhPZignXycpID4gLTEpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknKSBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScgJiYgdGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29kZSkpIHtcbiAgICAgIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgIH1cbiAgICBmYWxsYmFja0NvZGVzLmZvckVhY2goZmMgPT4ge1xuICAgICAgaWYgKGNvZGVzLmluZGV4T2YoZmMpIDwgMCkgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShmYykpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2RlcztcbiAgfVxufVxuXG5jb25zdCBzdWZmaXhlc09yZGVyID0ge1xuICB6ZXJvOiAwLFxuICBvbmU6IDEsXG4gIHR3bzogMixcbiAgZmV3OiAzLFxuICBtYW55OiA0LFxuICBvdGhlcjogNVxufTtcbmNvbnN0IGR1bW15UnVsZSA9IHtcbiAgc2VsZWN0OiBjb3VudCA9PiBjb3VudCA9PT0gMSA/ICdvbmUnIDogJ290aGVyJyxcbiAgcmVzb2x2ZWRPcHRpb25zOiAoKSA9PiAoe1xuICAgIHBsdXJhbENhdGVnb3JpZXM6IFsnb25lJywgJ290aGVyJ11cbiAgfSlcbn07XG5jbGFzcyBQbHVyYWxSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlVXRpbHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5sYW5ndWFnZVV0aWxzID0gbGFuZ3VhZ2VVdGlscztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ3BsdXJhbFJlc29sdmVyJyk7XG4gICAgdGhpcy5wbHVyYWxSdWxlc0NhY2hlID0ge307XG4gIH1cbiAgYWRkUnVsZShsbmcsIG9iaikge1xuICAgIHRoaXMucnVsZXNbbG5nXSA9IG9iajtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMucGx1cmFsUnVsZXNDYWNoZSA9IHt9O1xuICB9XG4gIGdldFJ1bGUoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBjbGVhbmVkQ29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUgPT09ICdkZXYnID8gJ2VuJyA6IGNvZGUpO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLm9yZGluYWwgPyAnb3JkaW5hbCcgOiAnY2FyZGluYWwnO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY2xlYW5lZENvZGUsXG4gICAgICB0eXBlXG4gICAgfSk7XG4gICAgaWYgKGNhY2hlS2V5IGluIHRoaXMucGx1cmFsUnVsZXNDYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1cmFsUnVsZXNDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGxldCBydWxlO1xuICAgIHRyeSB7XG4gICAgICBydWxlID0gbmV3IEludGwuUGx1cmFsUnVsZXMoY2xlYW5lZENvZGUsIHtcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIUludGwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ05vIEludGwgc3VwcG9ydCwgcGxlYXNlIHVzZSBhbiBJbnRsIHBvbHlmaWxsIScpO1xuICAgICAgICByZXR1cm4gZHVtbXlSdWxlO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2RlLm1hdGNoKC8tfF8vKSkgcmV0dXJuIGR1bW15UnVsZTtcbiAgICAgIGNvbnN0IGxuZ1BhcnQgPSB0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICBydWxlID0gdGhpcy5nZXRSdWxlKGxuZ1BhcnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGVbY2FjaGVLZXldID0gcnVsZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICBuZWVkc1BsdXJhbChjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcnVsZSA9IHRoaXMuZ2V0UnVsZSgnZGV2Jywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJ1bGU/LnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMubGVuZ3RoID4gMTtcbiAgfVxuICBnZXRQbHVyYWxGb3Jtc09mS2V5KGNvZGUsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdWZmaXhlcyhjb2RlLCBvcHRpb25zKS5tYXAoc3VmZml4ID0+IGAke2tleX0ke3N1ZmZpeH1gKTtcbiAgfVxuICBnZXRTdWZmaXhlcyhjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcnVsZSA9IHRoaXMuZ2V0UnVsZSgnZGV2Jywgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5zb3J0KChwbHVyYWxDYXRlZ29yeTEsIHBsdXJhbENhdGVnb3J5MikgPT4gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTFdIC0gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTJdKS5tYXAocGx1cmFsQ2F0ZWdvcnkgPT4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cGx1cmFsQ2F0ZWdvcnl9YCk7XG4gIH1cbiAgZ2V0U3VmZml4KGNvZGUsIGNvdW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMucHJlcGVuZH0ke29wdGlvbnMub3JkaW5hbCA/IGBvcmRpbmFsJHt0aGlzLm9wdGlvbnMucHJlcGVuZH1gIDogJyd9JHtydWxlLnNlbGVjdChjb3VudCl9YDtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2Fybihgbm8gcGx1cmFsIHJ1bGUgZm91bmQgZm9yOiAke2NvZGV9YCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4KCdkZXYnLCBjb3VudCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuY29uc3QgZGVlcEZpbmRXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YSwgZGVmYXVsdERhdGEsIGtleSkge1xuICBsZXQga2V5U2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnLic7XG4gIGxldCBpZ25vcmVKU09OU3RydWN0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICBsZXQgcGF0aCA9IGdldFBhdGhXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSk7XG4gIGlmICghcGF0aCAmJiBpZ25vcmVKU09OU3RydWN0dXJlICYmIGlzU3RyaW5nKGtleSkpIHtcbiAgICBwYXRoID0gZGVlcEZpbmQoZGF0YSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHBhdGggPSBkZWVwRmluZChkZWZhdWx0RGF0YSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbmNvbnN0IHJlZ2V4U2FmZSA9IHZhbCA9PiB2YWwucmVwbGFjZSgvXFwkL2csICckJCQkJyk7XG5jbGFzcyBJbnRlcnBvbGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnaW50ZXJwb2xhdG9yJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnM/LmludGVycG9sYXRpb24/LmZvcm1hdCB8fCAodmFsdWUgPT4gdmFsdWUpO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJwb2xhdGlvbikgb3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgZXNjYXBlVmFsdWU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGVzY2FwZTogZXNjYXBlJDEsXG4gICAgICBlc2NhcGVWYWx1ZSxcbiAgICAgIHVzZVJhd1ZhbHVlVG9Fc2NhcGUsXG4gICAgICBwcmVmaXgsXG4gICAgICBwcmVmaXhFc2NhcGVkLFxuICAgICAgc3VmZml4LFxuICAgICAgc3VmZml4RXNjYXBlZCxcbiAgICAgIGZvcm1hdFNlcGFyYXRvcixcbiAgICAgIHVuZXNjYXBlU3VmZml4LFxuICAgICAgdW5lc2NhcGVQcmVmaXgsXG4gICAgICBuZXN0aW5nUHJlZml4LFxuICAgICAgbmVzdGluZ1ByZWZpeEVzY2FwZWQsXG4gICAgICBuZXN0aW5nU3VmZml4LFxuICAgICAgbmVzdGluZ1N1ZmZpeEVzY2FwZWQsXG4gICAgICBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvcixcbiAgICAgIG1heFJlcGxhY2VzLFxuICAgICAgYWx3YXlzRm9ybWF0XG4gICAgfSA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLmVzY2FwZSA9IGVzY2FwZSQxICE9PSB1bmRlZmluZWQgPyBlc2NhcGUkMSA6IGVzY2FwZTtcbiAgICB0aGlzLmVzY2FwZVZhbHVlID0gZXNjYXBlVmFsdWUgIT09IHVuZGVmaW5lZCA/IGVzY2FwZVZhbHVlIDogdHJ1ZTtcbiAgICB0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUgPSB1c2VSYXdWYWx1ZVRvRXNjYXBlICE9PSB1bmRlZmluZWQgPyB1c2VSYXdWYWx1ZVRvRXNjYXBlIDogZmFsc2U7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXggPyByZWdleEVzY2FwZShwcmVmaXgpIDogcHJlZml4RXNjYXBlZCB8fCAne3snO1xuICAgIHRoaXMuc3VmZml4ID0gc3VmZml4ID8gcmVnZXhFc2NhcGUoc3VmZml4KSA6IHN1ZmZpeEVzY2FwZWQgfHwgJ319JztcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IGZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy51bmVzY2FwZVByZWZpeCA9IHVuZXNjYXBlU3VmZml4ID8gJycgOiB1bmVzY2FwZVByZWZpeCB8fCAnLSc7XG4gICAgdGhpcy51bmVzY2FwZVN1ZmZpeCA9IHRoaXMudW5lc2NhcGVQcmVmaXggPyAnJyA6IHVuZXNjYXBlU3VmZml4IHx8ICcnO1xuICAgIHRoaXMubmVzdGluZ1ByZWZpeCA9IG5lc3RpbmdQcmVmaXggPyByZWdleEVzY2FwZShuZXN0aW5nUHJlZml4KSA6IG5lc3RpbmdQcmVmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCckdCgnKTtcbiAgICB0aGlzLm5lc3RpbmdTdWZmaXggPSBuZXN0aW5nU3VmZml4ID8gcmVnZXhFc2NhcGUobmVzdGluZ1N1ZmZpeCkgOiBuZXN0aW5nU3VmZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnKScpO1xuICAgIHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgPSBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy5tYXhSZXBsYWNlcyA9IG1heFJlcGxhY2VzIHx8IDEwMDA7XG4gICAgdGhpcy5hbHdheXNGb3JtYXQgPSBhbHdheXNGb3JtYXQgIT09IHVuZGVmaW5lZCA/IGFsd2F5c0Zvcm1hdCA6IGZhbHNlO1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zKSB0aGlzLmluaXQodGhpcy5vcHRpb25zKTtcbiAgfVxuICByZXNldFJlZ0V4cCgpIHtcbiAgICBjb25zdCBnZXRPclJlc2V0UmVnRXhwID0gKGV4aXN0aW5nUmVnRXhwLCBwYXR0ZXJuKSA9PiB7XG4gICAgICBpZiAoZXhpc3RpbmdSZWdFeHA/LnNvdXJjZSA9PT0gcGF0dGVybikge1xuICAgICAgICBleGlzdGluZ1JlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdSZWdFeHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xuICAgIH07XG4gICAgdGhpcy5yZWdleHAgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMucmVnZXhwLCBgJHt0aGlzLnByZWZpeH0oLis/KSR7dGhpcy5zdWZmaXh9YCk7XG4gICAgdGhpcy5yZWdleHBVbmVzY2FwZSA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5yZWdleHBVbmVzY2FwZSwgYCR7dGhpcy5wcmVmaXh9JHt0aGlzLnVuZXNjYXBlUHJlZml4fSguKz8pJHt0aGlzLnVuZXNjYXBlU3VmZml4fSR7dGhpcy5zdWZmaXh9YCk7XG4gICAgdGhpcy5uZXN0aW5nUmVnZXhwID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLm5lc3RpbmdSZWdleHAsIGAke3RoaXMubmVzdGluZ1ByZWZpeH0oLis/KSR7dGhpcy5uZXN0aW5nU3VmZml4fWApO1xuICB9XG4gIGludGVycG9sYXRlKHN0ciwgZGF0YSwgbG5nLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgcmVwbGFjZXM7XG4gICAgY29uc3QgZGVmYXVsdERhdGEgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gJiYgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyB8fCB7fTtcbiAgICBjb25zdCBoYW5kbGVGb3JtYXQgPSBrZXkgPT4ge1xuICAgICAgaWYgKGtleS5pbmRleE9mKHRoaXMuZm9ybWF0U2VwYXJhdG9yKSA8IDApIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXksIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IsIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx3YXlzRm9ybWF0ID8gdGhpcy5mb3JtYXQocGF0aCwgdW5kZWZpbmVkLCBsbmcsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbmtleToga2V5XG4gICAgICAgIH0pIDogcGF0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBrZXkuc3BsaXQodGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgICAgY29uc3QgayA9IHAuc2hpZnQoKS50cmltKCk7XG4gICAgICBjb25zdCBmID0gcC5qb2luKHRoaXMuZm9ybWF0U2VwYXJhdG9yKS50cmltKCk7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVlcEZpbmRXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGssIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IsIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlKSwgZiwgbG5nLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGludGVycG9sYXRpb25rZXk6IGtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZXNldFJlZ0V4cCgpO1xuICAgIGNvbnN0IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9IG9wdGlvbnM/Lm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyO1xuICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IG9wdGlvbnM/LmludGVycG9sYXRpb24/LnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyA6IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcztcbiAgICBjb25zdCB0b2RvcyA9IFt7XG4gICAgICByZWdleDogdGhpcy5yZWdleHBVbmVzY2FwZSxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHJlZ2V4U2FmZSh2YWwpXG4gICAgfSwge1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwLFxuICAgICAgc2FmZVZhbHVlOiB2YWwgPT4gdGhpcy5lc2NhcGVWYWx1ZSA/IHJlZ2V4U2FmZSh0aGlzLmVzY2FwZSh2YWwpKSA6IHJlZ2V4U2FmZSh2YWwpXG4gICAgfV07XG4gICAgdG9kb3MuZm9yRWFjaCh0b2RvID0+IHtcbiAgICAgIHJlcGxhY2VzID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHRvZG8ucmVnZXguZXhlYyhzdHIpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRWYXIgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHZhbHVlID0gaGFuZGxlRm9ybWF0KG1hdGNoZWRWYXIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyKHN0ciwgbWF0Y2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFsdWUgPSBpc1N0cmluZyh0ZW1wKSA/IHRlbXAgOiAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG1hdGNoZWRWYXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byBwYXNzIGluIHZhcmlhYmxlICR7bWF0Y2hlZFZhcn0gZm9yIGludGVycG9sYXRpbmcgJHtzdHJ9YCk7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpbmcodmFsdWUpICYmICF0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1ha2VTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhZmVWYWx1ZSA9IHRvZG8uc2FmZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobWF0Y2hbMF0sIHNhZmVWYWx1ZSk7XG4gICAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggLT0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlcysrO1xuICAgICAgICBpZiAocmVwbGFjZXMgPj0gdGhpcy5tYXhSZXBsYWNlcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBuZXN0KHN0ciwgZmMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgY2xvbmVkT3B0aW9ucztcbiAgICBjb25zdCBoYW5kbGVIYXNPcHRpb25zID0gKGtleSwgaW5oZXJpdGVkT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3Qgc2VwID0gdGhpcy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvcjtcbiAgICAgIGlmIChrZXkuaW5kZXhPZihzZXApIDwgMCkgcmV0dXJuIGtleTtcbiAgICAgIGNvbnN0IGMgPSBrZXkuc3BsaXQobmV3IFJlZ0V4cChgJHtzZXB9WyBdKntgKSk7XG4gICAgICBsZXQgb3B0aW9uc1N0cmluZyA9IGB7JHtjWzFdfWA7XG4gICAgICBrZXkgPSBjWzBdO1xuICAgICAgb3B0aW9uc1N0cmluZyA9IHRoaXMuaW50ZXJwb2xhdGUob3B0aW9uc1N0cmluZywgY2xvbmVkT3B0aW9ucyk7XG4gICAgICBjb25zdCBtYXRjaGVkU2luZ2xlUXVvdGVzID0gb3B0aW9uc1N0cmluZy5tYXRjaCgvJy9nKTtcbiAgICAgIGNvbnN0IG1hdGNoZWREb3VibGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC9cIi9nKTtcbiAgICAgIGlmICgobWF0Y2hlZFNpbmdsZVF1b3Rlcz8ubGVuZ3RoID8/IDApICUgMiA9PT0gMCAmJiAhbWF0Y2hlZERvdWJsZVF1b3RlcyB8fCBtYXRjaGVkRG91YmxlUXVvdGVzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgb3B0aW9uc1N0cmluZyA9IG9wdGlvbnNTdHJpbmcucmVwbGFjZSgvJy9nLCAnXCInKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNsb25lZE9wdGlvbnMgPSBKU09OLnBhcnNlKG9wdGlvbnNTdHJpbmcpO1xuICAgICAgICBpZiAoaW5oZXJpdGVkT3B0aW9ucykgY2xvbmVkT3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5pbmhlcml0ZWRPcHRpb25zLFxuICAgICAgICAgIC4uLmNsb25lZE9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgZmFpbGVkIHBhcnNpbmcgb3B0aW9ucyBzdHJpbmcgaW4gbmVzdGluZyBmb3Iga2V5ICR7a2V5fWAsIGUpO1xuICAgICAgICByZXR1cm4gYCR7a2V5fSR7c2VwfSR7b3B0aW9uc1N0cmluZ31gO1xuICAgICAgfVxuICAgICAgaWYgKGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlICYmIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlLmluZGV4T2YodGhpcy5wcmVmaXgpID4gLTEpIGRlbGV0ZSBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICB3aGlsZSAobWF0Y2ggPSB0aGlzLm5lc3RpbmdSZWdleHAuZXhlYyhzdHIpKSB7XG4gICAgICBsZXQgZm9ybWF0dGVycyA9IFtdO1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNsb25lZE9wdGlvbnMgPSBjbG9uZWRPcHRpb25zLnJlcGxhY2UgJiYgIWlzU3RyaW5nKGNsb25lZE9wdGlvbnMucmVwbGFjZSkgPyBjbG9uZWRPcHRpb25zLnJlcGxhY2UgOiBjbG9uZWRPcHRpb25zO1xuICAgICAgY2xvbmVkT3B0aW9ucy5hcHBseVBvc3RQcm9jZXNzb3IgPSBmYWxzZTtcbiAgICAgIGRlbGV0ZSBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGxldCBkb1JlZHVjZSA9IGZhbHNlO1xuICAgICAgaWYgKG1hdGNoWzBdLmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpICE9PSAtMSAmJiAhL3suKn0vLnRlc3QobWF0Y2hbMV0pKSB7XG4gICAgICAgIGNvbnN0IHIgPSBtYXRjaFsxXS5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcikubWFwKGVsZW0gPT4gZWxlbS50cmltKCkpO1xuICAgICAgICBtYXRjaFsxXSA9IHIuc2hpZnQoKTtcbiAgICAgICAgZm9ybWF0dGVycyA9IHI7XG4gICAgICAgIGRvUmVkdWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZmMoaGFuZGxlSGFzT3B0aW9ucy5jYWxsKHRoaXMsIG1hdGNoWzFdLnRyaW0oKSwgY2xvbmVkT3B0aW9ucyksIGNsb25lZE9wdGlvbnMpO1xuICAgICAgaWYgKHZhbHVlICYmIG1hdGNoWzBdID09PSBzdHIgJiYgIWlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byByZXNvbHZlICR7bWF0Y2hbMV19IGZvciBuZXN0aW5nICR7c3RyfWApO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVkdWNlKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVycy5yZWR1Y2UoKHYsIGYpID0+IHRoaXMuZm9ybWF0KHYsIGYsIG9wdGlvbnMubG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBtYXRjaFsxXS50cmltKClcbiAgICAgICAgfSksIHZhbHVlLnRyaW0oKSk7XG4gICAgICB9XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgdmFsdWUpO1xuICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5jb25zdCBwYXJzZUZvcm1hdFN0ciA9IGZvcm1hdFN0ciA9PiB7XG4gIGxldCBmb3JtYXROYW1lID0gZm9ybWF0U3RyLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBjb25zdCBmb3JtYXRPcHRpb25zID0ge307XG4gIGlmIChmb3JtYXRTdHIuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICBjb25zdCBwID0gZm9ybWF0U3RyLnNwbGl0KCcoJyk7XG4gICAgZm9ybWF0TmFtZSA9IHBbMF0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc3Qgb3B0U3RyID0gcFsxXS5zdWJzdHJpbmcoMCwgcFsxXS5sZW5ndGggLSAxKTtcbiAgICBpZiAoZm9ybWF0TmFtZSA9PT0gJ2N1cnJlbmN5JyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLmN1cnJlbmN5KSBmb3JtYXRPcHRpb25zLmN1cnJlbmN5ID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE5hbWUgPT09ICdyZWxhdGl2ZXRpbWUnICYmIG9wdFN0ci5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMucmFuZ2UpIGZvcm1hdE9wdGlvbnMucmFuZ2UgPSBvcHRTdHIudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRzID0gb3B0U3RyLnNwbGl0KCc7Jyk7XG4gICAgICBvcHRzLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gb3B0LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgY29uc3QgdmFsID0gcmVzdC5qb2luKCc6JykudHJpbSgpLnJlcGxhY2UoL14nK3wnKyQvZywgJycpO1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRLZXkgPSBrZXkudHJpbSgpO1xuICAgICAgICAgIGlmICghZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSkgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAnZmFsc2UnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gJ3RydWUnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0TmFtZSxcbiAgICBmb3JtYXRPcHRpb25zXG4gIH07XG59O1xuY29uc3QgY3JlYXRlQ2FjaGVkRm9ybWF0dGVyID0gZm4gPT4ge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuICByZXR1cm4gKHZhbCwgbG5nLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IG9wdEZvckNhY2hlID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmludGVycG9sYXRpb25rZXkgJiYgb3B0aW9ucy5mb3JtYXRQYXJhbXMgJiYgb3B0aW9ucy5mb3JtYXRQYXJhbXNbb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSAmJiBvcHRpb25zW29wdGlvbnMuaW50ZXJwb2xhdGlvbmtleV0pIHtcbiAgICAgIG9wdEZvckNhY2hlID0ge1xuICAgICAgICAuLi5vcHRGb3JDYWNoZSxcbiAgICAgICAgW29wdGlvbnMuaW50ZXJwb2xhdGlvbmtleV06IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gbG5nICsgSlNPTi5zdHJpbmdpZnkob3B0Rm9yQ2FjaGUpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjYWNoZVtrZXldO1xuICAgIGlmICghZm9ybWF0dGVyKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBmbihnZXRDbGVhbmVkQ29kZShsbmcpLCBvcHRpb25zKTtcbiAgICAgIGNhY2hlW2tleV0gPSBmb3JtYXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZXIodmFsKTtcbiAgfTtcbn07XG5jbGFzcyBGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnZm9ybWF0dGVyJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdHMgPSB7XG4gICAgICBudW1iZXI6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIGN1cnJlbmN5OiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBkYXRldGltZTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICByZWxhdGl2ZXRpbWU6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCwgb3B0LnJhbmdlIHx8ICdkYXknKTtcbiAgICAgIH0pLFxuICAgICAgbGlzdDogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgIH07XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9XG4gIGluaXQoc2VydmljZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgaW50ZXJwb2xhdGlvbjoge31cbiAgICB9O1xuICAgIHRoaXMuZm9ybWF0U2VwYXJhdG9yID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG4gIH1cbiAgYWRkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gZmM7XG4gIH1cbiAgYWRkQ2FjaGVkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKGZjKTtcbiAgfVxuICBmb3JtYXQodmFsdWUsIGZvcm1hdCwgbG5nKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGNvbnN0IGZvcm1hdHMgPSBmb3JtYXQuc3BsaXQodGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgIGlmIChmb3JtYXRzLmxlbmd0aCA+IDEgJiYgZm9ybWF0c1swXS5pbmRleE9mKCcoJykgPiAxICYmIGZvcm1hdHNbMF0uaW5kZXhPZignKScpIDwgMCAmJiBmb3JtYXRzLmZpbmQoZiA9PiBmLmluZGV4T2YoJyknKSA+IC0xKSkge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gZm9ybWF0cy5maW5kSW5kZXgoZiA9PiBmLmluZGV4T2YoJyknKSA+IC0xKTtcbiAgICAgIGZvcm1hdHNbMF0gPSBbZm9ybWF0c1swXSwgLi4uZm9ybWF0cy5zcGxpY2UoMSwgbGFzdEluZGV4KV0uam9pbih0aGlzLmZvcm1hdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdHMucmVkdWNlKChtZW0sIGYpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9ybWF0TmFtZSxcbiAgICAgICAgZm9ybWF0T3B0aW9uc1xuICAgICAgfSA9IHBhcnNlRm9ybWF0U3RyKGYpO1xuICAgICAgaWYgKHRoaXMuZm9ybWF0c1tmb3JtYXROYW1lXSkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gbWVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHZhbE9wdGlvbnMgPSBvcHRpb25zPy5mb3JtYXRQYXJhbXM/LltvcHRpb25zLmludGVycG9sYXRpb25rZXldIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGwgPSB2YWxPcHRpb25zLmxvY2FsZSB8fCB2YWxPcHRpb25zLmxuZyB8fCBvcHRpb25zLmxvY2FsZSB8fCBvcHRpb25zLmxuZyB8fCBsbmc7XG4gICAgICAgICAgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKG1lbSwgbCwge1xuICAgICAgICAgICAgLi4uZm9ybWF0T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi52YWxPcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHRoZXJlIHdhcyBubyBmb3JtYXQgZnVuY3Rpb24gZm9yICR7Zm9ybWF0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW07XG4gICAgfSwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuY29uc3QgcmVtb3ZlUGVuZGluZyA9IChxLCBuYW1lKSA9PiB7XG4gIGlmIChxLnBlbmRpbmdbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBxLnBlbmRpbmdbbmFtZV07XG4gICAgcS5wZW5kaW5nQ291bnQtLTtcbiAgfVxufTtcbmNsYXNzIENvbm5lY3RvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGJhY2tlbmQsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBzZXJ2aWNlcy5sYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnYmFja2VuZENvbm5lY3RvcicpO1xuICAgIHRoaXMud2FpdGluZ1JlYWRzID0gW107XG4gICAgdGhpcy5tYXhQYXJhbGxlbFJlYWRzID0gb3B0aW9ucy5tYXhQYXJhbGxlbFJlYWRzIHx8IDEwO1xuICAgIHRoaXMucmVhZGluZ0NhbGxzID0gMDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPj0gMCA/IG9wdGlvbnMubWF4UmV0cmllcyA6IDU7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCA+PSAxID8gb3B0aW9ucy5yZXRyeVRpbWVvdXQgOiAzNTA7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmJhY2tlbmQ/LmluaXQ/LihzZXJ2aWNlcywgb3B0aW9ucy5iYWNrZW5kLCBvcHRpb25zKTtcbiAgfVxuICBxdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRvTG9hZCA9IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSB7fTtcbiAgICBjb25zdCB0b0xvYWRMYW5ndWFnZXMgPSB7fTtcbiAgICBjb25zdCB0b0xvYWROYW1lc3BhY2VzID0ge307XG4gICAgbGFuZ3VhZ2VzLmZvckVhY2gobG5nID0+IHtcbiAgICAgIGxldCBoYXNBbGxOYW1lc3BhY2VzID0gdHJ1ZTtcbiAgICAgIG5hbWVzcGFjZXMuZm9yRWFjaChucyA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtsbmd9fCR7bnN9YDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlbG9hZCAmJiB0aGlzLnN0b3JlLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZVtuYW1lXSA8IDApIDsgZWxzZSBpZiAodGhpcy5zdGF0ZVtuYW1lXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChwZW5kaW5nW25hbWVdID09PSB1bmRlZmluZWQpIHBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAxO1xuICAgICAgICAgIGhhc0FsbE5hbWVzcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodG9Mb2FkW25hbWVdID09PSB1bmRlZmluZWQpIHRvTG9hZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZE5hbWVzcGFjZXNbbnNdID09PSB1bmRlZmluZWQpIHRvTG9hZE5hbWVzcGFjZXNbbnNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWhhc0FsbE5hbWVzcGFjZXMpIHRvTG9hZExhbmd1YWdlc1tsbmddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmtleXModG9Mb2FkKS5sZW5ndGggfHwgT2JqZWN0LmtleXMocGVuZGluZykubGVuZ3RoKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICBwZW5kaW5nLFxuICAgICAgICBwZW5kaW5nQ291bnQ6IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCxcbiAgICAgICAgbG9hZGVkOiB7fSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdG9Mb2FkOiBPYmplY3Qua2V5cyh0b0xvYWQpLFxuICAgICAgcGVuZGluZzogT2JqZWN0LmtleXMocGVuZGluZyksXG4gICAgICB0b0xvYWRMYW5ndWFnZXM6IE9iamVjdC5rZXlzKHRvTG9hZExhbmd1YWdlcyksXG4gICAgICB0b0xvYWROYW1lc3BhY2VzOiBPYmplY3Qua2V5cyh0b0xvYWROYW1lc3BhY2VzKVxuICAgIH07XG4gIH1cbiAgbG9hZGVkKG5hbWUsIGVyciwgZGF0YSkge1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgaWYgKGVycikgdGhpcy5lbWl0KCdmYWlsZWRMb2FkaW5nJywgbG5nLCBucywgZXJyKTtcbiAgICBpZiAoIWVyciAmJiBkYXRhKSB7XG4gICAgICB0aGlzLnN0b3JlLmFkZFJlc291cmNlQnVuZGxlKGxuZywgbnMsIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHNraXBDb3B5OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZVtuYW1lXSA9IGVyciA/IC0xIDogMjtcbiAgICBpZiAoZXJyICYmIGRhdGEpIHRoaXMuc3RhdGVbbmFtZV0gPSAwO1xuICAgIGNvbnN0IGxvYWRlZCA9IHt9O1xuICAgIHRoaXMucXVldWUuZm9yRWFjaChxID0+IHtcbiAgICAgIHB1c2hQYXRoKHEubG9hZGVkLCBbbG5nXSwgbnMpO1xuICAgICAgcmVtb3ZlUGVuZGluZyhxLCBuYW1lKTtcbiAgICAgIGlmIChlcnIpIHEuZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIGlmIChxLnBlbmRpbmdDb3VudCA9PT0gMCAmJiAhcS5kb25lKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHEubG9hZGVkKS5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkW2xdKSBsb2FkZWRbbF0gPSB7fTtcbiAgICAgICAgICBjb25zdCBsb2FkZWRLZXlzID0gcS5sb2FkZWRbbF07XG4gICAgICAgICAgaWYgKGxvYWRlZEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2FkZWRLZXlzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgIGlmIChsb2FkZWRbbF1bbl0gPT09IHVuZGVmaW5lZCkgbG9hZGVkW2xdW25dID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHEuZG9uZSA9IHRydWU7XG4gICAgICAgIGlmIChxLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBxLmNhbGxiYWNrKHEuZXJyb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIGxvYWRlZCk7XG4gICAgdGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuZmlsdGVyKHEgPT4gIXEuZG9uZSk7XG4gIH1cbiAgcmVhZChsbmcsIG5zLCBmY05hbWUpIHtcbiAgICBsZXQgdHJpZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgbGV0IHdhaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRoaXMucmV0cnlUaW1lb3V0O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgIGlmICghbG5nLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHt9KTtcbiAgICBpZiAodGhpcy5yZWFkaW5nQ2FsbHMgPj0gdGhpcy5tYXhQYXJhbGxlbFJlYWRzKSB7XG4gICAgICB0aGlzLndhaXRpbmdSZWFkcy5wdXNoKHtcbiAgICAgICAgbG5nLFxuICAgICAgICBucyxcbiAgICAgICAgZmNOYW1lLFxuICAgICAgICB0cmllZCxcbiAgICAgICAgd2FpdCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlYWRpbmdDYWxscysrO1xuICAgIGNvbnN0IHJlc29sdmVyID0gKGVyciwgZGF0YSkgPT4ge1xuICAgICAgdGhpcy5yZWFkaW5nQ2FsbHMtLTtcbiAgICAgIGlmICh0aGlzLndhaXRpbmdSZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLndhaXRpbmdSZWFkcy5zaGlmdCgpO1xuICAgICAgICB0aGlzLnJlYWQobmV4dC5sbmcsIG5leHQubnMsIG5leHQuZmNOYW1lLCBuZXh0LnRyaWVkLCBuZXh0LndhaXQsIG5leHQuY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKGVyciAmJiBkYXRhICYmIHRyaWVkIDwgdGhpcy5tYXhSZXRyaWVzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVhZC5jYWxsKHRoaXMsIGxuZywgbnMsIGZjTmFtZSwgdHJpZWQgKyAxLCB3YWl0ICogMiwgY2FsbGJhY2spO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kW2ZjTmFtZV0uYmluZCh0aGlzLmJhY2tlbmQpO1xuICAgIGlmIChmYy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHIgPSBmYyhsbmcsIG5zKTtcbiAgICAgICAgaWYgKHIgJiYgdHlwZW9mIHIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHIudGhlbihkYXRhID0+IHJlc29sdmVyKG51bGwsIGRhdGEpKS5jYXRjaChyZXNvbHZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZXIobnVsbCwgcik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXNvbHZlcihlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZmMobG5nLCBucywgcmVzb2x2ZXIpO1xuICB9XG4gIHByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMuYmFja2VuZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignTm8gYmFja2VuZCB3YXMgYWRkZWQgdmlhIGkxOG5leHQudXNlLiBXaWxsIG5vdCBsb2FkIHJlc291cmNlcy4nKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcobGFuZ3VhZ2VzKSkgbGFuZ3VhZ2VzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsYW5ndWFnZXMpO1xuICAgIGlmIChpc1N0cmluZyhuYW1lc3BhY2VzKSkgbmFtZXNwYWNlcyA9IFtuYW1lc3BhY2VzXTtcbiAgICBjb25zdCB0b0xvYWQgPSB0aGlzLnF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBpZiAoIXRvTG9hZC50b0xvYWQubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRvTG9hZC5wZW5kaW5nLmxlbmd0aCkgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0xvYWQudG9Mb2FkLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLmxvYWRPbmUobmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHt9LCBjYWxsYmFjayk7XG4gIH1cbiAgcmVsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcywge1xuICAgICAgcmVsb2FkOiB0cnVlXG4gICAgfSwgY2FsbGJhY2spO1xuICB9XG4gIGxvYWRPbmUobmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgdGhpcy5yZWFkKGxuZywgbnMsICdyZWFkJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHRoaXMubG9nZ2VyLndhcm4oYCR7cHJlZml4fWxvYWRpbmcgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ30gZmFpbGVkYCwgZXJyKTtcbiAgICAgIGlmICghZXJyICYmIGRhdGEpIHRoaXMubG9nZ2VyLmxvZyhgJHtwcmVmaXh9bG9hZGVkIG5hbWVzcGFjZSAke25zfSBmb3IgbGFuZ3VhZ2UgJHtsbmd9YCwgZGF0YSk7XG4gICAgICB0aGlzLmxvYWRlZChuYW1lLCBlcnIsIGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIHNhdmVNaXNzaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIGlzVXBkYXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIGxldCBjbGIgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6ICgpID0+IHt9O1xuICAgIGlmICh0aGlzLnNlcnZpY2VzPy51dGlscz8uaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnNlcnZpY2VzPy51dGlscz8uaGFzTG9hZGVkTmFtZXNwYWNlKG5hbWVzcGFjZSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYGRpZCBub3Qgc2F2ZSBrZXkgXCIke2tleX1cIiBhcyB0aGUgbmFtZXNwYWNlIFwiJHtuYW1lc3BhY2V9XCIgd2FzIG5vdCB5ZXQgbG9hZGVkYCwgJ1RoaXMgbWVhbnMgc29tZXRoaW5nIElTIFdST05HIGluIHlvdXIgc2V0dXAuIFlvdSBhY2Nlc3MgdGhlIHQgZnVuY3Rpb24gYmVmb3JlIGkxOG5leHQuaW5pdCAvIGkxOG5leHQubG9hZE5hbWVzcGFjZSAvIGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2Ugd2FzIGRvbmUuIFdhaXQgZm9yIHRoZSBjYWxsYmFjayBvciBQcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGFjY2Vzc2luZyBpdCEhIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsIHx8IGtleSA9PT0gJycpIHJldHVybjtcbiAgICBpZiAodGhpcy5iYWNrZW5kPy5jcmVhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGlzVXBkYXRlXG4gICAgICB9O1xuICAgICAgY29uc3QgZmMgPSB0aGlzLmJhY2tlbmQuY3JlYXRlLmJpbmQodGhpcy5iYWNrZW5kKTtcbiAgICAgIGlmIChmYy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgaWYgKGZjLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIG9wdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByID0gZmMobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyICYmIHR5cGVvZiByLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHIudGhlbihkYXRhID0+IGNsYihudWxsLCBkYXRhKSkuY2F0Y2goY2xiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xiKG51bGwsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2xiKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIGNsYiwgb3B0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbGFuZ3VhZ2VzIHx8ICFsYW5ndWFnZXNbMF0pIHJldHVybjtcbiAgICB0aGlzLnN0b3JlLmFkZFJlc291cmNlKGxhbmd1YWdlc1swXSwgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICB9XG59XG5cbmNvbnN0IGdldCA9ICgpID0+ICh7XG4gIGRlYnVnOiBmYWxzZSxcbiAgaW5pdEFzeW5jOiB0cnVlLFxuICBuczogWyd0cmFuc2xhdGlvbiddLFxuICBkZWZhdWx0TlM6IFsndHJhbnNsYXRpb24nXSxcbiAgZmFsbGJhY2tMbmc6IFsnZGV2J10sXG4gIGZhbGxiYWNrTlM6IGZhbHNlLFxuICBzdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgbm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgbG9hZDogJ2FsbCcsXG4gIHByZWxvYWQ6IGZhbHNlLFxuICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdHJ1ZSxcbiAga2V5U2VwYXJhdG9yOiAnLicsXG4gIG5zU2VwYXJhdG9yOiAnOicsXG4gIHBsdXJhbFNlcGFyYXRvcjogJ18nLFxuICBjb250ZXh0U2VwYXJhdG9yOiAnXycsXG4gIHBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzOiBmYWxzZSxcbiAgc2F2ZU1pc3Npbmc6IGZhbHNlLFxuICB1cGRhdGVNaXNzaW5nOiBmYWxzZSxcbiAgc2F2ZU1pc3NpbmdUbzogJ2ZhbGxiYWNrJyxcbiAgc2F2ZU1pc3NpbmdQbHVyYWxzOiB0cnVlLFxuICBtaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsXG4gIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjogZmFsc2UsXG4gIHBvc3RQcm9jZXNzOiBmYWxzZSxcbiAgcG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQ6IGZhbHNlLFxuICByZXR1cm5OdWxsOiBmYWxzZSxcbiAgcmV0dXJuRW1wdHlTdHJpbmc6IHRydWUsXG4gIHJldHVybk9iamVjdHM6IGZhbHNlLFxuICBqb2luQXJyYXlzOiBmYWxzZSxcbiAgcmV0dXJuZWRPYmplY3RIYW5kbGVyOiBmYWxzZSxcbiAgcGFyc2VNaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsXG4gIGFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleTogZmFsc2UsXG4gIGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlOiBmYWxzZSxcbiAgb3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXI6IGFyZ3MgPT4ge1xuICAgIGxldCByZXQgPSB7fTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSByZXQgPSBhcmdzWzFdO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzFdKSkgcmV0LmRlZmF1bHRWYWx1ZSA9IGFyZ3NbMV07XG4gICAgaWYgKGlzU3RyaW5nKGFyZ3NbMl0pKSByZXQudERlc2NyaXB0aW9uID0gYXJnc1syXTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBhcmdzWzNdID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbM10gfHwgYXJnc1syXTtcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmV0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgaW50ZXJwb2xhdGlvbjoge1xuICAgIGVzY2FwZVZhbHVlOiB0cnVlLFxuICAgIGZvcm1hdDogdmFsdWUgPT4gdmFsdWUsXG4gICAgcHJlZml4OiAne3snLFxuICAgIHN1ZmZpeDogJ319JyxcbiAgICBmb3JtYXRTZXBhcmF0b3I6ICcsJyxcbiAgICB1bmVzY2FwZVByZWZpeDogJy0nLFxuICAgIG5lc3RpbmdQcmVmaXg6ICckdCgnLFxuICAgIG5lc3RpbmdTdWZmaXg6ICcpJyxcbiAgICBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvcjogJywnLFxuICAgIG1heFJlcGxhY2VzOiAxMDAwLFxuICAgIHNraXBPblZhcmlhYmxlczogdHJ1ZVxuICB9XG59KTtcbmNvbnN0IHRyYW5zZm9ybU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgaWYgKGlzU3RyaW5nKG9wdGlvbnMubnMpKSBvcHRpb25zLm5zID0gW29wdGlvbnMubnNdO1xuICBpZiAoaXNTdHJpbmcob3B0aW9ucy5mYWxsYmFja0xuZykpIG9wdGlvbnMuZmFsbGJhY2tMbmcgPSBbb3B0aW9ucy5mYWxsYmFja0xuZ107XG4gIGlmIChpc1N0cmluZyhvcHRpb25zLmZhbGxiYWNrTlMpKSBvcHRpb25zLmZhbGxiYWNrTlMgPSBbb3B0aW9ucy5mYWxsYmFja05TXTtcbiAgaWYgKG9wdGlvbnMuc3VwcG9ydGVkTG5ncz8uaW5kZXhPZj8uKCdjaW1vZGUnKSA8IDApIHtcbiAgICBvcHRpb25zLnN1cHBvcnRlZExuZ3MgPSBvcHRpb25zLnN1cHBvcnRlZExuZ3MuY29uY2F0KFsnY2ltb2RlJ10pO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbml0SW1tZWRpYXRlID09PSAnYm9vbGVhbicpIG9wdGlvbnMuaW5pdEFzeW5jID0gb3B0aW9ucy5pbml0SW1tZWRpYXRlO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmNvbnN0IGJpbmRNZW1iZXJGdW5jdGlvbnMgPSBpbnN0ID0+IHtcbiAgY29uc3QgbWVtcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KSk7XG4gIG1lbXMuZm9yRWFjaChtZW0gPT4ge1xuICAgIGlmICh0eXBlb2YgaW5zdFttZW1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnN0W21lbV0gPSBpbnN0W21lbV0uYmluZChpbnN0KTtcbiAgICB9XG4gIH0pO1xufTtcbmNsYXNzIEkxOG4gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2VydmljZXMgPSB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgdGhpcy5tb2R1bGVzID0ge1xuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICBiaW5kTWVtYmVyRnVuY3Rpb25zKHRoaXMpO1xuICAgIGlmIChjYWxsYmFjayAmJiAhdGhpcy5pc0luaXRpYWxpemVkICYmICFvcHRpb25zLmlzQ2xvbmUpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmluaXRBc3luYykge1xuICAgICAgICB0aGlzLmluaXQob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmluaXQob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIGluaXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0luaXRpYWxpemluZyA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlZmF1bHROUyA9PSBudWxsICYmIG9wdGlvbnMubnMpIHtcbiAgICAgIGlmIChpc1N0cmluZyhvcHRpb25zLm5zKSkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnM7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnMuaW5kZXhPZigndHJhbnNsYXRpb24nKSA8IDApIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0TlMgPSBvcHRpb25zLm5zWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWZPcHRzID0gZ2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmT3B0cyxcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLnRyYW5zZm9ybU9wdGlvbnMob3B0aW9ucylcbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgLi4uZGVmT3B0cy5pbnRlcnBvbGF0aW9uLFxuICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb25cbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCBjcmVhdGVDbGFzc09uRGVtYW5kID0gQ2xhc3NPck9iamVjdCA9PiB7XG4gICAgICBpZiAoIUNsYXNzT3JPYmplY3QpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBDbGFzc09yT2JqZWN0ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IENsYXNzT3JPYmplY3QoKTtcbiAgICAgIHJldHVybiBDbGFzc09yT2JqZWN0O1xuICAgIH07XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkge1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sb2dnZXIpIHtcbiAgICAgICAgYmFzZUxvZ2dlci5pbml0KGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxvZ2dlciksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQobnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXR0ZXI7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLm1vZHVsZXMuZm9ybWF0dGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0dGVyID0gRm9ybWF0dGVyO1xuICAgICAgfVxuICAgICAgY29uc3QgbHUgPSBuZXcgTGFuZ3VhZ2VVdGlsKHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUodGhpcy5vcHRpb25zLnJlc291cmNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNlcnZpY2VzO1xuICAgICAgcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgICAgcy5yZXNvdXJjZVN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHMubGFuZ3VhZ2VVdGlscyA9IGx1O1xuICAgICAgcy5wbHVyYWxSZXNvbHZlciA9IG5ldyBQbHVyYWxSZXNvbHZlcihsdSwge1xuICAgICAgICBwcmVwZW5kOiB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yLFxuICAgICAgICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4XG4gICAgICB9KTtcbiAgICAgIGlmIChmb3JtYXR0ZXIgJiYgKCF0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgfHwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID09PSBkZWZPcHRzLmludGVycG9sYXRpb24uZm9ybWF0KSkge1xuICAgICAgICBzLmZvcm1hdHRlciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQoZm9ybWF0dGVyKTtcbiAgICAgICAgcy5mb3JtYXR0ZXIuaW5pdChzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPSBzLmZvcm1hdHRlci5mb3JtYXQuYmluZChzLmZvcm1hdHRlcik7XG4gICAgICB9XG4gICAgICBzLmludGVycG9sYXRvciA9IG5ldyBJbnRlcnBvbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIHMudXRpbHMgPSB7XG4gICAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogdGhpcy5oYXNMb2FkZWROYW1lc3BhY2UuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3IoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3Rvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcikge1xuICAgICAgICBzLmxhbmd1YWdlRGV0ZWN0b3IgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKTtcbiAgICAgICAgaWYgKHMubGFuZ3VhZ2VEZXRlY3Rvci5pbml0KSBzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdChzLCB0aGlzLm9wdGlvbnMuZGV0ZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KSB7XG4gICAgICAgIHMuaTE4bkZvcm1hdCA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQpO1xuICAgICAgICBpZiAocy5pMThuRm9ybWF0LmluaXQpIHMuaTE4bkZvcm1hdC5pbml0KHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IodGhpcy5zZXJ2aWNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNsYXRvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICBpZiAobS5pbml0KSBtLmluaXQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgY29uc3QgY29kZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgaWYgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbMF0gIT09ICdkZXYnKSB0aGlzLm9wdGlvbnMubG5nID0gY29kZXNbMF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBubyBsYW5ndWFnZURldGVjdG9yIGlzIHVzZWQgYW5kIG5vIGxuZyBpcyBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlQXBpID0gWydnZXRSZXNvdXJjZScsICdoYXNSZXNvdXJjZUJ1bmRsZScsICdnZXRSZXNvdXJjZUJ1bmRsZScsICdnZXREYXRhQnlMYW5ndWFnZSddO1xuICAgIHN0b3JlQXBpLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmVBcGlDaGFpbmVkID0gWydhZGRSZXNvdXJjZScsICdhZGRSZXNvdXJjZXMnLCAnYWRkUmVzb3VyY2VCdW5kbGUnLCAncmVtb3ZlUmVzb3VyY2VCdW5kbGUnXTtcbiAgICBzdG9yZUFwaUNoYWluZWQuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaW5pc2ggPSAoZXJyLCB0KSA9PiB7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCAmJiAhdGhpcy5pbml0aWFsaXplZFN0b3JlT25jZSkgdGhpcy5sb2dnZXIud2FybignaW5pdDogaTE4bmV4dCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLiBZb3Ugc2hvdWxkIGNhbGwgaW5pdCBqdXN0IG9uY2UhJyk7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzQ2xvbmUpIHRoaXMubG9nZ2VyLmxvZygnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0KTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB0KTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sYW5ndWFnZXMgJiYgIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIGZpbmlzaChudWxsLCB0aGlzLnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNoYW5nZUxhbmd1YWdlKHRoaXMub3B0aW9ucy5sbmcsIGZpbmlzaCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc291cmNlcyB8fCAhdGhpcy5vcHRpb25zLmluaXRBc3luYykge1xuICAgICAgbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGxvYWQsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZFJlc291cmNlcyhsYW5ndWFnZSkge1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgICBsZXQgdXNlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY29uc3QgdXNlZExuZyA9IGlzU3RyaW5nKGxhbmd1YWdlKSA/IGxhbmd1YWdlIDogdGhpcy5sYW5ndWFnZTtcbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnZnVuY3Rpb24nKSB1c2VkQ2FsbGJhY2sgPSBsYW5ndWFnZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgdGhpcy5vcHRpb25zLnBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzKSB7XG4gICAgICBpZiAodXNlZExuZz8udG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScgJiYgKCF0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCB0aGlzLm9wdGlvbnMucHJlbG9hZC5sZW5ndGggPT09IDApKSByZXR1cm4gdXNlZENhbGxiYWNrKCk7XG4gICAgICBjb25zdCB0b0xvYWQgPSBbXTtcbiAgICAgIGNvbnN0IGFwcGVuZCA9IGxuZyA9PiB7XG4gICAgICAgIGlmICghbG5nKSByZXR1cm47XG4gICAgICAgIGlmIChsbmcgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxuZyk7XG4gICAgICAgIGxuZ3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAobCA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgICBpZiAodG9Mb2FkLmluZGV4T2YobCkgPCAwKSB0b0xvYWQucHVzaChsKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKCF1c2VkTG5nKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICAgIGZhbGxiYWNrcy5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCh1c2VkTG5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkPy5mb3JFYWNoPy4obCA9PiBhcHBlbmQobCkpO1xuICAgICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCB0aGlzLm9wdGlvbnMubnMsIGUgPT4ge1xuICAgICAgICBpZiAoIWUgJiYgIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlKSB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UodGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIHVzZWRDYWxsYmFjayhlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VkQ2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG4gIHJlbG9hZFJlc291cmNlcyhsbmdzLCBucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGxuZ3M7XG4gICAgICBsbmdzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG5zO1xuICAgICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghbG5ncykgbG5ncyA9IHRoaXMubGFuZ3VhZ2VzO1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLm5zO1xuICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gbm9vcDtcbiAgICB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IucmVsb2FkKGxuZ3MsIG5zLCBlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgdXNlKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhbiB1bmRlZmluZWQgbW9kdWxlISBQbGVhc2UgY2hlY2sgdGhlIG9iamVjdCB5b3UgYXJlIHBhc3NpbmcgdG8gaTE4bmV4dC51c2UoKScpO1xuICAgIGlmICghbW9kdWxlLnR5cGUpIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBwYXNzaW5nIGEgd3JvbmcgbW9kdWxlISBQbGVhc2UgY2hlY2sgdGhlIG9iamVjdCB5b3UgYXJlIHBhc3NpbmcgdG8gaTE4bmV4dC51c2UoKScpO1xuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2JhY2tlbmQnKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuYmFja2VuZCA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbG9nZ2VyJyB8fCBtb2R1bGUubG9nICYmIG1vZHVsZS53YXJuICYmIG1vZHVsZS5lcnJvcikge1xuICAgICAgdGhpcy5tb2R1bGVzLmxvZ2dlciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbGFuZ3VhZ2VEZXRlY3RvcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdpMThuRm9ybWF0Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ3Bvc3RQcm9jZXNzb3InKSB7XG4gICAgICBwb3N0UHJvY2Vzc29yLmFkZFBvc3RQcm9jZXNzb3IobW9kdWxlKTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnZm9ybWF0dGVyJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmZvcm1hdHRlciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnM3JkUGFydHknKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuZXh0ZXJuYWwucHVzaChtb2R1bGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRSZXNvbHZlZExhbmd1YWdlKGwpIHtcbiAgICBpZiAoIWwgfHwgIXRoaXMubGFuZ3VhZ2VzKSByZXR1cm47XG4gICAgaWYgKFsnY2ltb2RlJywgJ2RldiddLmluZGV4T2YobCkgPiAtMSkgcmV0dXJuO1xuICAgIGZvciAobGV0IGxpID0gMDsgbGkgPCB0aGlzLmxhbmd1YWdlcy5sZW5ndGg7IGxpKyspIHtcbiAgICAgIGNvbnN0IGxuZ0luTG5ncyA9IHRoaXMubGFuZ3VhZ2VzW2xpXTtcbiAgICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGxuZ0luTG5ncykgPiAtMSkgY29udGludWU7XG4gICAgICBpZiAodGhpcy5zdG9yZS5oYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nSW5MbmdzKSkge1xuICAgICAgICB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgPSBsbmdJbkxuZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGFuZ2VMYW5ndWFnZShsbmcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9IGxuZztcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdGhpcy5lbWl0KCdsYW5ndWFnZUNoYW5naW5nJywgbG5nKTtcbiAgICBjb25zdCBzZXRMbmdQcm9wcyA9IGwgPT4ge1xuICAgICAgdGhpcy5sYW5ndWFnZSA9IGw7XG4gICAgICB0aGlzLmxhbmd1YWdlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobCk7XG4gICAgICB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UobCk7XG4gICAgfTtcbiAgICBjb25zdCBkb25lID0gKGVyciwgbCkgPT4ge1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgc2V0TG5nUHJvcHMobCk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRvci5jaGFuZ2VMYW5ndWFnZShsKTtcbiAgICAgICAgdGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbWl0KCdsYW5ndWFnZUNoYW5nZWQnLCBsKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdsYW5ndWFnZUNoYW5nZWQnLCBsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi50KC4uLmFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudCguLi5hcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRMbmcgPSBsbmdzID0+IHtcbiAgICAgIGlmICghbG5nICYmICFsbmdzICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvcikgbG5ncyA9IFtdO1xuICAgICAgY29uc3QgbCA9IGlzU3RyaW5nKGxuZ3MpID8gbG5ncyA6IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRCZXN0TWF0Y2hGcm9tQ29kZXMobG5ncyk7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAoIXRoaXMubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzZXRMbmdQcm9wcyhsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHJhbnNsYXRvci5sYW5ndWFnZSkgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3I/LmNhY2hlVXNlckxhbmd1YWdlPy4obCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRSZXNvdXJjZXMobCwgZXJyID0+IHtcbiAgICAgICAgZG9uZShlcnIsIGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgc2V0TG5nKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKSk7XG4gICAgfSBlbHNlIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkudGhlbihzZXRMbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdChzZXRMbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMbmcobG5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGdldEZpeGVkVChsbmcsIG5zLCBrZXlQcmVmaXgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjb25zdCBmaXhlZFQgPSBmdW5jdGlvbiAoa2V5LCBvcHRzKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMiA/IF9sZW4zIC0gMiA6IDApLCBfa2V5MyA9IDI7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gMl0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBfdGhpczMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihba2V5LCBvcHRzXS5jb25jYXQocmVzdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxuZyA9IG9wdGlvbnMubG5nIHx8IGZpeGVkVC5sbmc7XG4gICAgICBvcHRpb25zLmxuZ3MgPSBvcHRpb25zLmxuZ3MgfHwgZml4ZWRULmxuZ3M7XG4gICAgICBvcHRpb25zLm5zID0gb3B0aW9ucy5ucyB8fCBmaXhlZFQubnM7XG4gICAgICBpZiAob3B0aW9ucy5rZXlQcmVmaXggIT09ICcnKSBvcHRpb25zLmtleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4IHx8IGtleVByZWZpeCB8fCBmaXhlZFQua2V5UHJlZml4O1xuICAgICAgY29uc3Qga2V5U2VwYXJhdG9yID0gX3RoaXMzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcbiAgICAgIGxldCByZXN1bHRLZXk7XG4gICAgICBpZiAob3B0aW9ucy5rZXlQcmVmaXggJiYgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJlc3VsdEtleSA9IGtleS5tYXAoayA9PiBgJHtvcHRpb25zLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2t9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRLZXkgPSBvcHRpb25zLmtleVByZWZpeCA/IGAke29wdGlvbnMua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMzLnQocmVzdWx0S2V5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmIChpc1N0cmluZyhsbmcpKSB7XG4gICAgICBmaXhlZFQubG5nID0gbG5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXhlZFQubG5ncyA9IGxuZztcbiAgICB9XG4gICAgZml4ZWRULm5zID0gbnM7XG4gICAgZml4ZWRULmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICByZXR1cm4gZml4ZWRUO1xuICB9XG4gIHQoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0b3I/LnRyYW5zbGF0ZSguLi5hcmdzKTtcbiAgfVxuICBleGlzdHMoKSB7XG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0b3I/LmV4aXN0cyguLi5hcmdzKTtcbiAgfVxuICBzZXREZWZhdWx0TmFtZXNwYWNlKG5zKSB7XG4gICAgdGhpcy5vcHRpb25zLmRlZmF1bHROUyA9IG5zO1xuICB9XG4gIGhhc0xvYWRlZE5hbWVzcGFjZShucykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuZXh0IHdhcyBub3QgaW5pdGlhbGl6ZWQnLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5sYW5ndWFnZXMgfHwgIXRoaXMubGFuZ3VhZ2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuLmxhbmd1YWdlcyB3ZXJlIHVuZGVmaW5lZCBvciBlbXB0eScsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG5nID0gb3B0aW9ucy5sbmcgfHwgdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8IHRoaXMubGFuZ3VhZ2VzWzBdO1xuICAgIGNvbnN0IGZhbGxiYWNrTG5nID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIDogZmFsc2U7XG4gICAgY29uc3QgbGFzdExuZyA9IHRoaXMubGFuZ3VhZ2VzW3RoaXMubGFuZ3VhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGxvYWROb3RQZW5kaW5nID0gKGwsIG4pID0+IHtcbiAgICAgIGNvbnN0IGxvYWRTdGF0ZSA9IHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5zdGF0ZVtgJHtsfXwke259YF07XG4gICAgICByZXR1cm4gbG9hZFN0YXRlID09PSAtMSB8fCBsb2FkU3RhdGUgPT09IDAgfHwgbG9hZFN0YXRlID09PSAyO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMucHJlY2hlY2spIHtcbiAgICAgIGNvbnN0IHByZVJlc3VsdCA9IG9wdGlvbnMucHJlY2hlY2sodGhpcywgbG9hZE5vdFBlbmRpbmcpO1xuICAgICAgaWYgKHByZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcHJlUmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IuYmFja2VuZCB8fCB0aGlzLm9wdGlvbnMucmVzb3VyY2VzICYmICF0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChsb2FkTm90UGVuZGluZyhsbmcsIG5zKSAmJiAoIWZhbGxiYWNrTG5nIHx8IGxvYWROb3RQZW5kaW5nKGxhc3RMbmcsIG5zKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2FkTmFtZXNwYWNlcyhucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubnMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKG5zKSkgbnMgPSBbbnNdO1xuICAgIG5zLmZvckVhY2gobiA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5zLmluZGV4T2YobikgPCAwKSB0aGlzLm9wdGlvbnMubnMucHVzaChuKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZExhbmd1YWdlcyhsbmdzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoaXNTdHJpbmcobG5ncykpIGxuZ3MgPSBbbG5nc107XG4gICAgY29uc3QgcHJlbG9hZGVkID0gdGhpcy5vcHRpb25zLnByZWxvYWQgfHwgW107XG4gICAgY29uc3QgbmV3TG5ncyA9IGxuZ3MuZmlsdGVyKGxuZyA9PiBwcmVsb2FkZWQuaW5kZXhPZihsbmcpIDwgMCAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuaXNTdXBwb3J0ZWRDb2RlKGxuZykpO1xuICAgIGlmICghbmV3TG5ncy5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnByZWxvYWQgPSBwcmVsb2FkZWQuY29uY2F0KG5ld0xuZ3MpO1xuICAgIHRoaXMubG9hZFJlc291cmNlcyhlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBkaXIobG5nKSB7XG4gICAgaWYgKCFsbmcpIGxuZyA9IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCAodGhpcy5sYW5ndWFnZXM/Lmxlbmd0aCA+IDAgPyB0aGlzLmxhbmd1YWdlc1swXSA6IHRoaXMubGFuZ3VhZ2UpO1xuICAgIGlmICghbG5nKSByZXR1cm4gJ3J0bCc7XG4gICAgY29uc3QgcnRsTG5ncyA9IFsnYXInLCAnc2h1JywgJ3NxcicsICdzc2gnLCAneGFhJywgJ3loZCcsICd5dWQnLCAnYWFvJywgJ2FiaCcsICdhYnYnLCAnYWNtJywgJ2FjcScsICdhY3cnLCAnYWN4JywgJ2FjeScsICdhZGYnLCAnYWRzJywgJ2FlYicsICdhZWMnLCAnYWZiJywgJ2FqcCcsICdhcGMnLCAnYXBkJywgJ2FyYicsICdhcnEnLCAnYXJzJywgJ2FyeScsICdhcnonLCAnYXV6JywgJ2F2bCcsICdheWgnLCAnYXlsJywgJ2F5bicsICdheXAnLCAnYmJ6JywgJ3BnYScsICdoZScsICdpdycsICdwcycsICdwYnQnLCAncGJ1JywgJ3BzdCcsICdwcnAnLCAncHJkJywgJ3VnJywgJ3VyJywgJ3lkZCcsICd5ZHMnLCAneWloJywgJ2ppJywgJ3lpJywgJ2hibycsICdtZW4nLCAneG1uJywgJ2ZhJywgJ2pwcicsICdwZW8nLCAncGVzJywgJ3BycycsICdkdicsICdzYW0nLCAnY2tiJ107XG4gICAgY29uc3QgbGFuZ3VhZ2VVdGlscyA9IHRoaXMuc2VydmljZXM/Lmxhbmd1YWdlVXRpbHMgfHwgbmV3IExhbmd1YWdlVXRpbChnZXQoKSk7XG4gICAgcmV0dXJuIHJ0bExuZ3MuaW5kZXhPZihsYW5ndWFnZVV0aWxzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGxuZykpID4gLTEgfHwgbG5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignLWFyYWInKSA+IDEgPyAncnRsJyA6ICdsdHInO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBJMThuKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICBjbG9uZUluc3RhbmNlKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gICAgY29uc3QgZm9ya1Jlc291cmNlU3RvcmUgPSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkgZGVsZXRlIG9wdGlvbnMuZm9ya1Jlc291cmNlU3RvcmU7XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAuLi57XG4gICAgICAgIGlzQ2xvbmU6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb25lID0gbmV3IEkxOG4obWVyZ2VkT3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZGVidWcgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbG9uZS5sb2dnZXIgPSBjbG9uZS5sb2dnZXIuY2xvbmUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG1lbWJlcnNUb0NvcHkgPSBbJ3N0b3JlJywgJ3NlcnZpY2VzJywgJ2xhbmd1YWdlJ107XG4gICAgbWVtYmVyc1RvQ29weS5mb3JFYWNoKG0gPT4ge1xuICAgICAgY2xvbmVbbV0gPSB0aGlzW21dO1xuICAgIH0pO1xuICAgIGNsb25lLnNlcnZpY2VzID0ge1xuICAgICAgLi4udGhpcy5zZXJ2aWNlc1xuICAgIH07XG4gICAgY2xvbmUuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgaWYgKGZvcmtSZXNvdXJjZVN0b3JlKSB7XG4gICAgICBjb25zdCBjbG9uZWREYXRhID0gT2JqZWN0LmtleXModGhpcy5zdG9yZS5kYXRhKS5yZWR1Y2UoKHByZXYsIGwpID0+IHtcbiAgICAgICAgcHJldltsXSA9IHtcbiAgICAgICAgICAuLi50aGlzLnN0b3JlLmRhdGFbbF1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHByZXZbbF0pLnJlZHVjZSgoYWNjLCBuKSA9PiB7XG4gICAgICAgICAgYWNjW25dID0ge1xuICAgICAgICAgICAgLi4ucHJldltsXVtuXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgfSwge30pO1xuICAgICAgY2xvbmUuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZShjbG9uZWREYXRhLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgIGNsb25lLnNlcnZpY2VzLnJlc291cmNlU3RvcmUgPSBjbG9uZS5zdG9yZTtcbiAgICB9XG4gICAgY2xvbmUudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKGNsb25lLnNlcnZpY2VzLCBtZXJnZWRPcHRpb25zKTtcbiAgICBjbG9uZS50cmFuc2xhdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuICAgICAgY2xvbmUuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgY2xvbmUuaW5pdChtZXJnZWRPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vcHRpb25zID0gbWVyZ2VkT3B0aW9ucztcbiAgICBjbG9uZS50cmFuc2xhdG9yLmJhY2tlbmRDb25uZWN0b3Iuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgIGxhbmd1YWdlczogdGhpcy5sYW5ndWFnZXMsXG4gICAgICByZXNvbHZlZExhbmd1YWdlOiB0aGlzLnJlc29sdmVkTGFuZ3VhZ2VcbiAgICB9O1xuICB9XG59XG5jb25zdCBpbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2UoKTtcbmluc3RhbmNlLmNyZWF0ZUluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2UgPSBpbnN0YW5jZS5jcmVhdGVJbnN0YW5jZTtcbmNvbnN0IGRpciA9IGluc3RhbmNlLmRpcjtcbmNvbnN0IGluaXQgPSBpbnN0YW5jZS5pbml0O1xuY29uc3QgbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLmxvYWRSZXNvdXJjZXM7XG5jb25zdCByZWxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5yZWxvYWRSZXNvdXJjZXM7XG5jb25zdCB1c2UgPSBpbnN0YW5jZS51c2U7XG5jb25zdCBjaGFuZ2VMYW5ndWFnZSA9IGluc3RhbmNlLmNoYW5nZUxhbmd1YWdlO1xuY29uc3QgZ2V0Rml4ZWRUID0gaW5zdGFuY2UuZ2V0Rml4ZWRUO1xuY29uc3QgdCA9IGluc3RhbmNlLnQ7XG5jb25zdCBleGlzdHMgPSBpbnN0YW5jZS5leGlzdHM7XG5jb25zdCBzZXREZWZhdWx0TmFtZXNwYWNlID0gaW5zdGFuY2Uuc2V0RGVmYXVsdE5hbWVzcGFjZTtcbmNvbnN0IGhhc0xvYWRlZE5hbWVzcGFjZSA9IGluc3RhbmNlLmhhc0xvYWRlZE5hbWVzcGFjZTtcbmNvbnN0IGxvYWROYW1lc3BhY2VzID0gaW5zdGFuY2UubG9hZE5hbWVzcGFjZXM7XG5jb25zdCBsb2FkTGFuZ3VhZ2VzID0gaW5zdGFuY2UubG9hZExhbmd1YWdlcztcblxuZXhwb3J0IHsgY2hhbmdlTGFuZ3VhZ2UsIGNyZWF0ZUluc3RhbmNlLCBpbnN0YW5jZSBhcyBkZWZhdWx0LCBkaXIsIGV4aXN0cywgZ2V0Rml4ZWRULCBoYXNMb2FkZWROYW1lc3BhY2UsIGluaXQsIGxvYWRMYW5ndWFnZXMsIGxvYWROYW1lc3BhY2VzLCBsb2FkUmVzb3VyY2VzLCByZWxvYWRSZXNvdXJjZXMsIHNldERlZmF1bHROYW1lc3BhY2UsIHQsIHVzZSB9O1xuIl0sIm5hbWVzIjpbImlzU3RyaW5nIiwib2JqIiwiZGVmZXIiLCJyZXMiLCJyZWoiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtYWtlU3RyaW5nIiwib2JqZWN0IiwiY29weSIsImEiLCJzIiwidCIsImZvckVhY2giLCJtIiwibGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCIsImNsZWFuS2V5Iiwia2V5IiwiaW5kZXhPZiIsInJlcGxhY2UiLCJjYW5Ob3RUcmF2ZXJzZURlZXBlciIsImdldExhc3RPZlBhdGgiLCJwYXRoIiwiRW1wdHkiLCJzdGFjayIsInNwbGl0Iiwic3RhY2tJbmRleCIsImxlbmd0aCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImsiLCJzZXRQYXRoIiwibmV3VmFsdWUiLCJ1bmRlZmluZWQiLCJlIiwicCIsInNsaWNlIiwibGFzdCIsInB1c2hQYXRoIiwiY29uY2F0IiwicHVzaCIsImdldFBhdGgiLCJnZXRQYXRoV2l0aERlZmF1bHRzIiwiZGF0YSIsImRlZmF1bHREYXRhIiwidmFsdWUiLCJkZWVwRXh0ZW5kIiwidGFyZ2V0Iiwic291cmNlIiwib3ZlcndyaXRlIiwicHJvcCIsIlN0cmluZyIsInJlZ2V4RXNjYXBlIiwic3RyIiwiX2VudGl0eU1hcCIsImVzY2FwZSIsIlJlZ0V4cENhY2hlIiwiY29uc3RydWN0b3IiLCJjYXBhY2l0eSIsInJlZ0V4cE1hcCIsIk1hcCIsInJlZ0V4cFF1ZXVlIiwiZ2V0UmVnRXhwIiwicGF0dGVybiIsInJlZ0V4cEZyb21DYWNoZSIsImdldCIsInJlZ0V4cE5ldyIsIlJlZ0V4cCIsImRlbGV0ZSIsInNoaWZ0Iiwic2V0IiwiY2hhcnMiLCJsb29rc0xpa2VPYmplY3RQYXRoUmVnRXhwQ2FjaGUiLCJsb29rc0xpa2VPYmplY3RQYXRoIiwibnNTZXBhcmF0b3IiLCJrZXlTZXBhcmF0b3IiLCJwb3NzaWJsZUNoYXJzIiwiZmlsdGVyIiwiYyIsInIiLCJtYXAiLCJqb2luIiwibWF0Y2hlZCIsInRlc3QiLCJraSIsInN1YnN0cmluZyIsImRlZXBGaW5kIiwiYXJndW1lbnRzIiwidG9rZW5zIiwiY3VycmVudCIsImkiLCJuZXh0IiwibmV4dFBhdGgiLCJqIiwiZ2V0Q2xlYW5lZENvZGUiLCJjb2RlIiwiY29uc29sZUxvZ2dlciIsInR5cGUiLCJsb2ciLCJhcmdzIiwib3V0cHV0Iiwid2FybiIsImVycm9yIiwiY29uc29sZSIsImFwcGx5IiwiTG9nZ2VyIiwiY29uY3JldGVMb2dnZXIiLCJvcHRpb25zIiwiaW5pdCIsInByZWZpeCIsImxvZ2dlciIsImRlYnVnIiwiX2xlbiIsIkFycmF5IiwiX2tleSIsImZvcndhcmQiLCJfbGVuMiIsIl9rZXkyIiwiX2xlbjMiLCJfa2V5MyIsImRlcHJlY2F0ZSIsIl9sZW40IiwiX2tleTQiLCJsdmwiLCJkZWJ1Z09ubHkiLCJjcmVhdGUiLCJtb2R1bGVOYW1lIiwiY2xvbmUiLCJiYXNlTG9nZ2VyIiwiRXZlbnRFbWl0dGVyIiwib2JzZXJ2ZXJzIiwib24iLCJldmVudHMiLCJsaXN0ZW5lciIsImV2ZW50IiwibnVtTGlzdGVuZXJzIiwib2ZmIiwiZW1pdCIsImNsb25lZCIsImZyb20iLCJlbnRyaWVzIiwiX3JlZiIsIm9ic2VydmVyIiwibnVtVGltZXNBZGRlZCIsIl9yZWYyIiwiUmVzb3VyY2VTdG9yZSIsIm5zIiwiZGVmYXVsdE5TIiwiaWdub3JlSlNPTlN0cnVjdHVyZSIsImFkZE5hbWVzcGFjZXMiLCJyZW1vdmVOYW1lc3BhY2VzIiwiaW5kZXgiLCJzcGxpY2UiLCJnZXRSZXNvdXJjZSIsImxuZyIsImlzQXJyYXkiLCJyZXN1bHQiLCJhZGRSZXNvdXJjZSIsInNpbGVudCIsImFkZFJlc291cmNlcyIsInJlc291cmNlcyIsImFkZFJlc291cmNlQnVuZGxlIiwiZGVlcCIsInNraXBDb3B5IiwicGFjayIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInJlbW92ZVJlc291cmNlQnVuZGxlIiwiaGFzUmVzb3VyY2VCdW5kbGUiLCJnZXRSZXNvdXJjZUJ1bmRsZSIsImdldERhdGFCeUxhbmd1YWdlIiwiaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zIiwibiIsImtleXMiLCJmaW5kIiwidiIsInRvSlNPTiIsInBvc3RQcm9jZXNzb3IiLCJwcm9jZXNzb3JzIiwiYWRkUG9zdFByb2Nlc3NvciIsIm1vZHVsZSIsIm5hbWUiLCJoYW5kbGUiLCJ0cmFuc2xhdG9yIiwicHJvY2Vzc29yIiwicHJvY2VzcyIsImNoZWNrZWRMb2FkZWRGb3IiLCJzaG91bGRIYW5kbGVBc09iamVjdCIsIlRyYW5zbGF0b3IiLCJzZXJ2aWNlcyIsImNoYW5nZUxhbmd1YWdlIiwibGFuZ3VhZ2UiLCJleGlzdHMiLCJpbnRlcnBvbGF0aW9uIiwicmVzb2x2ZWQiLCJleHRyYWN0RnJvbUtleSIsIm5hbWVzcGFjZXMiLCJ3b3VsZENoZWNrRm9yTnNJbktleSIsInNlZW1zTmF0dXJhbExhbmd1YWdlIiwidXNlckRlZmluZWRLZXlTZXBhcmF0b3IiLCJ1c2VyRGVmaW5lZE5zU2VwYXJhdG9yIiwibWF0Y2giLCJpbnRlcnBvbGF0b3IiLCJuZXN0aW5nUmVnZXhwIiwicGFydHMiLCJ0cmFuc2xhdGUiLCJsYXN0S2V5Iiwib3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIiLCJyZXR1cm5EZXRhaWxzIiwibmFtZXNwYWNlIiwiYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUiLCJ0b0xvd2VyQ2FzZSIsInVzZWRLZXkiLCJleGFjdFVzZWRLZXkiLCJ1c2VkTG5nIiwidXNlZE5TIiwidXNlZFBhcmFtcyIsImdldFVzZWRQYXJhbXNEZXRhaWxzIiwicmVzVXNlZEtleSIsInJlc0V4YWN0VXNlZEtleSIsIm5vT2JqZWN0Iiwiam9pbkFycmF5cyIsImhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0IiwiaTE4bkZvcm1hdCIsImhhbmRsZUFzT2JqZWN0IiwibmVlZHNQbHVyYWxIYW5kbGluZyIsImNvdW50IiwiaGFzRGVmYXVsdFZhbHVlIiwiZGVmYXVsdFZhbHVlU3VmZml4IiwicGx1cmFsUmVzb2x2ZXIiLCJnZXRTdWZmaXgiLCJkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2siLCJvcmRpbmFsIiwibmVlZHNaZXJvU3VmZml4TG9va3VwIiwiZGVmYXVsdFZhbHVlIiwicGx1cmFsU2VwYXJhdG9yIiwicmVzRm9yT2JqSG5kbCIsInJlc1R5cGUiLCJ0b1N0cmluZyIsInJldHVybk9iamVjdHMiLCJyZXR1cm5lZE9iamVjdEhhbmRsZXIiLCJyZXNUeXBlSXNBcnJheSIsIm5ld0tleVRvVXNlIiwiZGVlcEtleSIsImV4dGVuZFRyYW5zbGF0aW9uIiwidXNlZERlZmF1bHQiLCJpc1ZhbGlkTG9va3VwIiwibWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5IiwicmVzRm9yTWlzc2luZyIsInVwZGF0ZU1pc3NpbmciLCJmayIsImxuZ3MiLCJmYWxsYmFja0xuZ3MiLCJsYW5ndWFnZVV0aWxzIiwiZ2V0RmFsbGJhY2tDb2RlcyIsImZhbGxiYWNrTG5nIiwic2F2ZU1pc3NpbmdUbyIsInRvUmVzb2x2ZUhpZXJhcmNoeSIsInNlbmQiLCJsIiwic3BlY2lmaWNEZWZhdWx0VmFsdWUiLCJkZWZhdWx0Rm9yTWlzc2luZyIsIm1pc3NpbmdLZXlIYW5kbGVyIiwiYmFja2VuZENvbm5lY3RvciIsInNhdmVNaXNzaW5nIiwic2F2ZU1pc3NpbmdQbHVyYWxzIiwic3VmZml4ZXMiLCJnZXRTdWZmaXhlcyIsInN1ZmZpeCIsImFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSIsInBhcnNlTWlzc2luZ0tleUhhbmRsZXIiLCJfdGhpcyIsImRlZmF1bHRWYXJpYWJsZXMiLCJza2lwSW50ZXJwb2xhdGlvbiIsInNraXBPblZhcmlhYmxlcyIsIm5lc3RCZWYiLCJuYiIsImludGVycG9sYXRlIiwibmEiLCJuZXN0QWZ0IiwibmVzdCIsImNvbnRleHQiLCJyZXNldCIsInBvc3RQcm9jZXNzIiwicG9zdFByb2Nlc3Nvck5hbWVzIiwiYXBwbHlQb3N0UHJvY2Vzc29yIiwicG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQiLCJpMThuUmVzb2x2ZWQiLCJmb3VuZCIsImV4dHJhY3RlZCIsImZhbGxiYWNrTlMiLCJuZWVkc0NvbnRleHRIYW5kbGluZyIsImNvZGVzIiwidXRpbHMiLCJoYXNMb2FkZWROYW1lc3BhY2UiLCJmaW5hbEtleXMiLCJhZGRMb29rdXBLZXlzIiwicGx1cmFsU3VmZml4IiwiemVyb1N1ZmZpeCIsIm9yZGluYWxQcmVmaXgiLCJjb250ZXh0S2V5IiwiY29udGV4dFNlcGFyYXRvciIsInBvc3NpYmxlS2V5IiwicG9wIiwicmV0dXJuTnVsbCIsInJldHVybkVtcHR5U3RyaW5nIiwicmVzb3VyY2VTdG9yZSIsIm9wdGlvbnNLZXlzIiwidXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhIiwib3B0aW9uIiwiTGFuZ3VhZ2VVdGlsIiwic3VwcG9ydGVkTG5ncyIsImdldFNjcmlwdFBhcnRGcm9tQ29kZSIsImZvcm1hdExhbmd1YWdlQ29kZSIsImdldExhbmd1YWdlUGFydEZyb21Db2RlIiwiZm9ybWF0dGVkQ29kZSIsIkludGwiLCJnZXRDYW5vbmljYWxMb2NhbGVzIiwibG93ZXJDYXNlTG5nIiwiY2xlYW5Db2RlIiwiaXNTdXBwb3J0ZWRDb2RlIiwibG9hZCIsIm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncyIsImdldEJlc3RNYXRjaEZyb21Db2RlcyIsImNsZWFuZWRMbmciLCJsbmdPbmx5Iiwic3VwcG9ydGVkTG5nIiwiZmFsbGJhY2tzIiwiZGVmYXVsdCIsImZhbGxiYWNrQ29kZSIsImZhbGxiYWNrQ29kZXMiLCJhZGRDb2RlIiwiZmMiLCJzdWZmaXhlc09yZGVyIiwiemVybyIsIm9uZSIsInR3byIsImZldyIsIm1hbnkiLCJvdGhlciIsImR1bW15UnVsZSIsInNlbGVjdCIsInJlc29sdmVkT3B0aW9ucyIsInBsdXJhbENhdGVnb3JpZXMiLCJQbHVyYWxSZXNvbHZlciIsInBsdXJhbFJ1bGVzQ2FjaGUiLCJhZGRSdWxlIiwicnVsZXMiLCJjbGVhckNhY2hlIiwiZ2V0UnVsZSIsImNsZWFuZWRDb2RlIiwiY2FjaGVLZXkiLCJydWxlIiwiUGx1cmFsUnVsZXMiLCJlcnIiLCJsbmdQYXJ0IiwibmVlZHNQbHVyYWwiLCJnZXRQbHVyYWxGb3Jtc09mS2V5Iiwic29ydCIsInBsdXJhbENhdGVnb3J5MSIsInBsdXJhbENhdGVnb3J5MiIsInBsdXJhbENhdGVnb3J5IiwicHJlcGVuZCIsImRlZXBGaW5kV2l0aERlZmF1bHRzIiwicmVnZXhTYWZlIiwidmFsIiwiSW50ZXJwb2xhdG9yIiwiZm9ybWF0IiwiZXNjYXBlVmFsdWUiLCJlc2NhcGUkMSIsInVzZVJhd1ZhbHVlVG9Fc2NhcGUiLCJwcmVmaXhFc2NhcGVkIiwic3VmZml4RXNjYXBlZCIsImZvcm1hdFNlcGFyYXRvciIsInVuZXNjYXBlU3VmZml4IiwidW5lc2NhcGVQcmVmaXgiLCJuZXN0aW5nUHJlZml4IiwibmVzdGluZ1ByZWZpeEVzY2FwZWQiLCJuZXN0aW5nU3VmZml4IiwibmVzdGluZ1N1ZmZpeEVzY2FwZWQiLCJuZXN0aW5nT3B0aW9uc1NlcGFyYXRvciIsIm1heFJlcGxhY2VzIiwiYWx3YXlzRm9ybWF0IiwicmVzZXRSZWdFeHAiLCJnZXRPclJlc2V0UmVnRXhwIiwiZXhpc3RpbmdSZWdFeHAiLCJsYXN0SW5kZXgiLCJyZWdleHAiLCJyZWdleHBVbmVzY2FwZSIsInJlcGxhY2VzIiwiaGFuZGxlRm9ybWF0IiwiaW50ZXJwb2xhdGlvbmtleSIsInRyaW0iLCJmIiwibWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyIiwidG9kb3MiLCJyZWdleCIsInNhZmVWYWx1ZSIsInRvZG8iLCJleGVjIiwibWF0Y2hlZFZhciIsInRlbXAiLCJjbG9uZWRPcHRpb25zIiwiaGFuZGxlSGFzT3B0aW9ucyIsImluaGVyaXRlZE9wdGlvbnMiLCJzZXAiLCJvcHRpb25zU3RyaW5nIiwibWF0Y2hlZFNpbmdsZVF1b3RlcyIsIm1hdGNoZWREb3VibGVRdW90ZXMiLCJmb3JtYXR0ZXJzIiwiZG9SZWR1Y2UiLCJlbGVtIiwicmVkdWNlIiwicGFyc2VGb3JtYXRTdHIiLCJmb3JtYXRTdHIiLCJmb3JtYXROYW1lIiwiZm9ybWF0T3B0aW9ucyIsIm9wdFN0ciIsImN1cnJlbmN5IiwicmFuZ2UiLCJvcHRzIiwib3B0IiwicmVzdCIsInRyaW1tZWRLZXkiLCJpc05hTiIsInBhcnNlSW50IiwiY3JlYXRlQ2FjaGVkRm9ybWF0dGVyIiwiZm4iLCJjYWNoZSIsIm9wdEZvckNhY2hlIiwiZm9ybWF0UGFyYW1zIiwiZm9ybWF0dGVyIiwiRm9ybWF0dGVyIiwiZm9ybWF0cyIsIm51bWJlciIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiZGF0ZXRpbWUiLCJEYXRlVGltZUZvcm1hdCIsInJlbGF0aXZldGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImxpc3QiLCJMaXN0Rm9ybWF0IiwiYWRkIiwiYWRkQ2FjaGVkIiwiZmluZEluZGV4IiwibWVtIiwiZm9ybWF0dGVkIiwidmFsT3B0aW9ucyIsImxvY2FsZSIsInJlbW92ZVBlbmRpbmciLCJxIiwicGVuZGluZyIsInBlbmRpbmdDb3VudCIsIkNvbm5lY3RvciIsImJhY2tlbmQiLCJzdG9yZSIsIndhaXRpbmdSZWFkcyIsIm1heFBhcmFsbGVsUmVhZHMiLCJyZWFkaW5nQ2FsbHMiLCJtYXhSZXRyaWVzIiwicmV0cnlUaW1lb3V0Iiwic3RhdGUiLCJxdWV1ZSIsInF1ZXVlTG9hZCIsImxhbmd1YWdlcyIsImNhbGxiYWNrIiwidG9Mb2FkIiwidG9Mb2FkTGFuZ3VhZ2VzIiwidG9Mb2FkTmFtZXNwYWNlcyIsImhhc0FsbE5hbWVzcGFjZXMiLCJyZWxvYWQiLCJsb2FkZWQiLCJlcnJvcnMiLCJkb25lIiwibG9hZGVkS2V5cyIsInJlYWQiLCJmY05hbWUiLCJ0cmllZCIsIndhaXQiLCJyZXNvbHZlciIsInNldFRpbWVvdXQiLCJiaW5kIiwidGhlbiIsImNhdGNoIiwicHJlcGFyZUxvYWRpbmciLCJsb2FkT25lIiwiZmFsbGJhY2tWYWx1ZSIsImlzVXBkYXRlIiwiY2xiIiwiaW5pdEFzeW5jIiwicHJlbG9hZCIsInNpbXBsaWZ5UGx1cmFsU3VmZml4IiwicGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMiLCJyZXQiLCJ0RGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1PcHRpb25zIiwiaW5pdEltbWVkaWF0ZSIsIm5vb3AiLCJiaW5kTWVtYmVyRnVuY3Rpb25zIiwiaW5zdCIsIm1lbXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0UHJvdG90eXBlT2YiLCJJMThuIiwibW9kdWxlcyIsImV4dGVybmFsIiwiaXNJbml0aWFsaXplZCIsImlzQ2xvbmUiLCJpc0luaXRpYWxpemluZyIsImRlZk9wdHMiLCJjcmVhdGVDbGFzc09uRGVtYW5kIiwiQ2xhc3NPck9iamVjdCIsImx1IiwibGFuZ3VhZ2VEZXRlY3RvciIsImRldGVjdGlvbiIsInN0b3JlQXBpIiwic3RvcmVBcGlDaGFpbmVkIiwiZGVmZXJyZWQiLCJmaW5pc2giLCJpbml0aWFsaXplZFN0b3JlT25jZSIsImxvYWRSZXNvdXJjZXMiLCJ1c2VkQ2FsbGJhY2siLCJhcHBlbmQiLCJyZXNvbHZlZExhbmd1YWdlIiwic2V0UmVzb2x2ZWRMYW5ndWFnZSIsInJlbG9hZFJlc291cmNlcyIsInVzZSIsIkVycm9yIiwibGkiLCJsbmdJbkxuZ3MiLCJfdGhpczIiLCJpc0xhbmd1YWdlQ2hhbmdpbmdUbyIsInNldExuZ1Byb3BzIiwic2V0TG5nIiwiY2FjaGVVc2VyTGFuZ3VhZ2UiLCJhc3luYyIsImRldGVjdCIsImdldEZpeGVkVCIsImtleVByZWZpeCIsIl90aGlzMyIsImZpeGVkVCIsInJlc3VsdEtleSIsIl9sZW41IiwiX2tleTUiLCJzZXREZWZhdWx0TmFtZXNwYWNlIiwibGFzdExuZyIsImxvYWROb3RQZW5kaW5nIiwibG9hZFN0YXRlIiwicHJlY2hlY2siLCJwcmVSZXN1bHQiLCJsb2FkTmFtZXNwYWNlcyIsImxvYWRMYW5ndWFnZXMiLCJwcmVsb2FkZWQiLCJuZXdMbmdzIiwiZGlyIiwicnRsTG5ncyIsImNyZWF0ZUluc3RhbmNlIiwiY2xvbmVJbnN0YW5jZSIsImZvcmtSZXNvdXJjZVN0b3JlIiwibWVyZ2VkT3B0aW9ucyIsIm1lbWJlcnNUb0NvcHkiLCJjbG9uZWREYXRhIiwicHJldiIsImFjYyIsIl9sZW42IiwiX2tleTYiLCJpbnN0YW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;